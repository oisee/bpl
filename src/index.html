<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="Content-Security-Policy" content="default-src 'self'; script-src 'self' 'unsafe-inline' 'unsafe-eval' https://cdn.jsdelivr.net; style-src 'self' 'unsafe-inline'; connect-src 'self';">
  <title>BPMN-lite Parser Demo</title>
  <!-- Import Mermaid library -->
  <script src="https://cdn.jsdelivr.net/npm/mermaid@10.6.1/dist/mermaid.min.js"></script>
  <style>
    body {
      font-family: Arial, sans-serif;
      margin: 0;
      padding: 0;
      display: flex;
      flex-direction: column;
      height: 100vh;
      overflow: hidden;
    }
    
    header {
      background-color: #333;
      color: white;
      padding: 10px;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }
    
    .title {
      font-size: 1.2em;
      font-weight: bold;
    }
    
    .main-container {
      display: flex;
      flex: 1;
      overflow: hidden;
    }
    
    .editor-container {
      flex: 1;
      height: 100%;
      border-right: 1px solid #ccc;
      display: flex;
      flex-direction: column;
      padding: 10px;
    }
    
    #code-editor {
      width: 100%;
      height: calc(100% - 50px);
      font-family: monospace;
      font-size: 14px;
      resize: none;
      padding: 10px;
      box-sizing: border-box;
      border: 1px solid #ccc;
      border-radius: 4px;
    }
    
    .editor-controls {
      margin-top: 10px;
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 10px;
    }
    
    .save-controls {
      display: flex;
      gap: 5px;
    }
    
    .save-controls button {
      background-color: #3498db;
      font-size: 0.9em;
      padding: 4px 8px;
    }
    
    .preview-container {
      flex: 1;
      height: 100%;
      overflow: auto;
      padding: 10px;
      display: flex;
      flex-direction: column;
    }
    
    .preview-tabs {
      display: flex;
      border-bottom: 1px solid #ccc;
      margin-bottom: 10px;
    }
    
    .preview-tab {
      padding: 5px 10px;
      cursor: pointer;
      border: 1px solid transparent;
    }
    
    .preview-tab.active {
      border: 1px solid #ccc;
      border-bottom: none;
      background-color: white;
    }
    
    .preview-content {
      flex: 1;
      overflow: auto;
      display: none;
    }
    
    .preview-content.active {
      display: block;
    }
    
    .ast-preview {
      font-family: monospace;
      white-space: pre-wrap;
      padding: 10px;
      background-color: #f5f5f5;
      border-radius: 4px;
      overflow: auto;
      height: 100%;
    }
    
    .mermaid-preview {
      height: 100%;
      display: flex;
      justify-content: center;
      align-items: center;
    }
    
    .error {
      color: red;
      padding: 10px;
      background-color: #ffeeee;
      border-radius: 4px;
      margin-bottom: 10px;
      display: none;
    }
    
    button {
      padding: 5px 10px;
      background-color: #4CAF50;
      color: white;
      border: none;
      border-radius: 4px;
      cursor: pointer;
    }
    
    button:hover {
      background-color: #45a049;
    }
    
    .export-menu {
      position: relative;
      display: inline-block;
    }
    
    .export-dropdown {
      display: none;
      position: absolute;
      background-color: white;
      min-width: 180px;
      box-shadow: 0px 8px 16px 0px rgba(0,0,0,0.2);
      z-index: 1000;
      border: 1px solid #ccc;
      border-radius: 4px;
      top: 100%;
      left: 0;
      margin-top: 2px;
    }
    
    .export-dropdown button {
      width: 100%;
      text-align: left;
      padding: 10px 15px;
      border: none;
      border-radius: 0;
      background-color: white;
      color: #333;
      font-size: 14px;
    }
    
    .export-dropdown button:hover {
      background-color: #f5f5f5;
    }
    
    .export-dropdown button:first-child {
      border-radius: 4px 4px 0 0;
    }
    
    .export-dropdown button:last-child {
      border-radius: 0 0 4px 4px;
    }
    
    .export-menu.active .export-dropdown {
      display: block;
    }
    
    .controls {
      display: flex;
      gap: 8px;
      padding: 10px;
      background-color: #f5f5f5;
      border-bottom: 1px solid #ccc;
      align-items: center;
    }
    
    .controls button {
      background-color: #4CAF50;
      color: white;
      border: none;
      padding: 6px 12px;
      cursor: pointer;
      border-radius: 4px;
      font-size: 14px;
    }
    
    .controls button:hover {
      background-color: #45a049;
    }
    
    .zoom-level {
      font-size: 14px;
      color: #666;
      min-width: 50px;
      text-align: center;
    }
  </style>
  <script>
    class BpmnLiteParser {
      constructor() {
        this.processes = [];
        this.lanes = {};
        this.tasks = {};
        this.connections = [];
        this.dataObjects = [];
        this.messages = [];
        this.events = [];
        this.currentProcess = null;
        this.currentLane = null;
        this.lastTask = null;
        this.taskScope = {};
        this.gatewayStack = [];
        this.connectionBreaks = []; // Track line numbers where "---" appears
        this.taskLineNumbers = {}; // Track line numbers for each task
      }

      parse(text) {
        // Reset state
        this.processes = [];
        this.lanes = {};
        this.tasks = {};
        this.connections = [];
        this.dataObjects = [];
        this.messages = [];
        this.events = [];
        this.currentProcess = null;
        this.currentLane = null;
        this.lastTask = null;
        this.taskScope = {};
        this.gatewayStack = [];
        this.connectionBreaks = [];
        this.taskLineNumbers = {};

        const lines = text.split('\n');
        
        // Create default process if none specified
        this.ensureProcess("Default Process");
        
        // First pass: collect processes, lanes, and tasks
        for (let i = 0; i < lines.length; i++) {
          const originalLine = lines[i];
          const line = originalLine.trim();
          if (!line) continue; // Skip empty lines
          
          // Check for connection break line
          if (line === '---' || line.match(/^-{3,}$/)) {
            this.connectionBreaks.push(i);
            continue; // Skip processing this line further
          }
          
          // Find first non-whitespace character for line type detection
          const firstNonWhitespace = line.match(/\S/);
          if (!firstNonWhitespace) continue;
          
          const firstChar = firstNonWhitespace[0];
          
          // Check for connected parts with -> or <- operators
          const parts = this.splitConnections(line);
          
          if (parts.length > 1) {
            // Process each part and create the connections
            let prevTaskId = null;
            let prevOperator = null;
            
            for (let j = 0; j < parts.length; j++) {
              const part = parts[j];
              
              // Skip operators
              if (part === '->' || part === '<-') {
                prevOperator = part;
                continue;
              }
              
              // Check if this part needs special handling for cross-lane references
              let taskId = null;
              
              // If we have a previous operator and this might be a reference to another task
              if (prevOperator && !this.isSpecialLine(part)) {
                // Try to resolve it as a task reference first
                taskId = this.resolveTaskId(part, true); // Create if not found
              }
              
              // If not resolved as reference, process normally
              if (!taskId) {
                taskId = this.processLinePart(part, part.charAt(0), i);
              }
              
              // Create connection if we have a previous task and operator
              if (prevTaskId && taskId && prevOperator) {
                if (prevOperator === '->') {
                  this.addConnection('flow', prevTaskId, taskId);
                } else if (prevOperator === '<-') {
                  this.addConnection('flow', taskId, prevTaskId);
                }
              }
              
              if (taskId) {
                prevTaskId = taskId;
              }
            }
          } else {
            // Single part, process normally (pass line number)
            this.processLinePart(line, firstChar, i);
          }
        }

        // Auto-inject connection breaks after End events
        this.injectConnectionBreaksAfterEndEvents(lines);

        // Automatically connect sequential tasks
        this.connectSequentialTasks();

        // Build the AST
        const ast = {
          type: 'bpmnModel',
          processes: this.processes.map(processName => ({
            type: 'process',
            name: processName,
            id: this.normalizeId(processName),
            lanes: Object.entries(this.lanes)
              .filter(([_, lane]) => lane.process === processName)
              .map(([laneName, lane]) => ({
                type: 'lane',
                name: laneName.replace('@', ''),
                id: this.normalizeId(laneName),
                elements: lane.tasks.map(taskId => this.tasks[taskId])
              }))
          })),
          connections: this.connections,
          dataObjects: this.dataObjects,
          messages: this.messages
        };

        return ast;
      }
      
      splitConnections(line) {
        const parts = [];
        let currentPart = '';
        let i = 0;
        
        while (i < line.length) {
          if (line.substr(i, 2) === '->' || line.substr(i, 2) === '<-') {
            // Add the current part if it exists
            if (currentPart.trim()) {
              parts.push(currentPart.trim());
            }
            // Add the operator as a separate part
            parts.push(line.substr(i, 2));
            currentPart = '';
            i += 2;
          } else {
            currentPart += line[i];
            i++;
          }
        }
        
        // Add the last part if it exists
        if (currentPart.trim()) {
          parts.push(currentPart.trim());
        }
        
        return parts;
      }
      
      processLinePart(line, firstChar, lineNumber) {
        // Process based on the first character
        let taskId = null;
        
        switch(firstChar) {
          case ':': // Process definition
            this.parseProcess(line);
            break;
          case '@': // Lane definition
            this.parseLane(line);
            break;
          case '^': // Message flow
            taskId = this.parseConnection(line);
            break;
          case '#': // Data object
            taskId = this.parseDataObject(line);
            break;
          case '?': // Gateway
            taskId = this.parseGateway(line);
            break;
          case '+': // Positive branch
          case '-': // Negative branch
            taskId = this.parseGatewayBranch(line, firstChar);
            break;
          case '"': // Comment
            taskId = this.parseComment(line);
            break;
          case '!': // Event
            taskId = this.parseEvent(line);
            break;
          case '/': // Technical comment (ignored)
            if (line.startsWith('//')) {
              // Ignore technical comments
              break;
            }
            // If not a comment, treat as a task
            taskId = this.parseTask(line);
            break;
          default:
            // Check if this is a task
            taskId = this.parseTask(line);
        }
        
        // Update last task if we created one
        if (taskId) {
          this.lastTask = taskId;
          // Store line number for this task
          if (lineNumber !== undefined) {
            this.taskLineNumbers[taskId] = lineNumber;
          }
        }
        
        return taskId;
      }
      
      parseEvent(line) {
        const eventName = line.substring(1).trim(); // Remove the ! prefix
        let eventType = 'intermediate';
        let eventId;
        let isProcessLevel = false;
        
        // Determine event type based on common keywords
        if (eventName.toLowerCase() === 'start') {
          eventType = 'start';
          // Start events are process-level, not lane-specific
          eventId = 'process_start';
          isProcessLevel = true;
        } else if (eventName.toLowerCase() === 'end') {
          eventType = 'end';
          // End events are process-level, not lane-specific
          eventId = 'process_end';
          isProcessLevel = true;
        } else {
          // For non-start/end events, we need a lane
          if (!this.currentLane) {
            // Create a default lane if needed for intermediate events
            this.parseLane('@Default');
          }
          const laneName = this.currentLane.replace('@', '');
          const normalizedLaneName = this.normalizeId(laneName);
          // Intermediate events can be lane-specific
          eventId = `${normalizedLaneName}_${this.normalizeId(eventName)}`;
        }
        
        // Only create the event if it doesn't already exist (for Start/End)
        if (!this.tasks[eventId]) {
          this.tasks[eventId] = {
            type: 'event',
            eventType: eventType,
            name: eventName,
            id: eventId,
            lane: isProcessLevel ? null : this.currentLane.replace('@', '') // Process-level events have no lane
          };
          
          // Track event for special handling
          this.events.push(eventId);
        }
        
        // For process-level events (Start/End), don't add to lane tasks
        if (!isProcessLevel && this.currentLane) {
          this.lanes[this.currentLane].tasks.push(eventId);
        }
        
        // Add event to scope for reference
        const simpleName = this.normalizeId(eventName);
        this.taskScope[simpleName] = eventId;
        if (this.currentLane) {
          const laneName = this.currentLane.replace('@', '');
          this.taskScope[`${laneName}.${simpleName}`] = eventId;
          this.taskScope[`@${laneName}.${simpleName}`] = eventId;
        }
        
        return eventId;
      }

      ensureProcess(name) {
        if (!this.processes.includes(name)) {
          this.processes.push(name);
          this.currentProcess = name;
        }
      }

      parseProcess(line) {
        const processName = line.substring(1).trim();
        this.ensureProcess(processName);
      }

      parseLane(line) {
        const laneName = line.trim();
        if (!this.lanes[laneName]) {
          this.lanes[laneName] = {
            process: this.currentProcess,
            tasks: []
          };
        }
        this.currentLane = laneName;
        this.lastTask = null; // Reset last task when changing lanes
      }

      parseTask(line) {
        if (!this.currentLane) {
          // Create a default lane if needed
          this.parseLane('@Default');
        }
        
        // Already trimmed the line in the main parse method
        if (!line) return null;
        
        let taskType = 'task';
        let taskName = line;
        let originalName = line; // Keep the original name for display
        
        // Check task type based on prefix
        if (line.startsWith('send:')) {
          taskType = 'send';
          taskName = line.substring(5).trim(); // Extract just the message name
          originalName = `send: ${taskName}`; // Keep the "send:" prefix in display name
        } else if (line.startsWith('receive:')) {
          taskType = 'receive';
          taskName = line.substring(8).trim(); // Extract just the message name
          originalName = `receive: ${taskName}`; // Keep the "receive:" prefix in display name
        }
        
        const laneName = this.currentLane.replace('@', '');
        const normalizedLaneName = this.normalizeId(laneName);
        const taskId = `${normalizedLaneName}_${this.normalizeId(originalName)}`;
        
        this.tasks[taskId] = {
          type: taskType,
          name: originalName, // Use original name with prefix for display
          messageName: taskType === 'send' || taskType === 'receive' ? taskName : null, // Store message name separately
          id: taskId,
          lane: laneName
        };
        
        this.lanes[this.currentLane].tasks.push(taskId);
        
        // Add task to scope for reference in connections
        // Use simplified name without prefixes for lookup
        const simpleName = this.normalizeId(taskName);
        this.taskScope[simpleName] = taskId;
        this.taskScope[`${laneName}.${simpleName}`] = taskId;
        this.taskScope[`@${laneName}.${simpleName}`] = taskId;
        
        // Also add the full name with prefix for reference
        const fullName = this.normalizeId(originalName);
        this.taskScope[fullName] = taskId;
        this.taskScope[`${laneName}.${fullName}`] = taskId;
        this.taskScope[`@${laneName}.${fullName}`] = taskId;
        
        return taskId;
      }

      parseGateway(line) {
        if (!this.currentLane) {
          // Create a default lane if needed
          this.parseLane('@Default');
        }
        
        const gatewayName = line.substring(1).trim();
        const laneName = this.currentLane.replace('@', '');
        const normalizedLaneName = this.normalizeId(laneName);
        const gatewayId = `${normalizedLaneName}_${this.normalizeId(gatewayName)}`;
        
        this.tasks[gatewayId] = {
          type: 'gateway',
          gatewayType: 'exclusive',
          name: gatewayName,
          id: gatewayId,
          lane: laneName,
          branches: []
        };
        
        this.lanes[this.currentLane].tasks.push(gatewayId);
        
        // Add gateway to scope for reference
        const simpleName = this.normalizeId(gatewayName);
        this.taskScope[simpleName] = gatewayId;
        this.taskScope[`${laneName}.${simpleName}`] = gatewayId;
        this.taskScope[`@${laneName}.${simpleName}`] = gatewayId;
        
        // Push to gateway stack
        this.gatewayStack.push(gatewayId);
        
        return gatewayId;
      }

      parseGatewayBranch(line, branchChar) {
        if (this.gatewayStack.length === 0) {
          // No gateway to attach to
          return null;
        }
        
        const parentGateway = this.gatewayStack[this.gatewayStack.length - 1];
        let branchName = line.substring(1).trim();
        const laneName = this.currentLane.replace('@', '');
        const normalizedLaneName = this.normalizeId(laneName);
        
        // Check if branch contains arrow operators (e.g., "cancel order -> !End")
        // If so, only use the first part as the branch name
        if (branchName.includes('->') || branchName.includes('<-')) {
          const parts = this.splitConnections(branchName);
          if (parts.length > 0) {
            branchName = parts[0]; // Use only the first part as branch name
          }
        }
        
        // Check if this is a direct End event branch (just "!End" or "End")
        if (branchName.toLowerCase() === '!end' || branchName.toLowerCase() === 'end') {
          // Don't create a branch task, connect directly to the process-level end event
          const endEventId = 'process_end';
          
          // Ensure process-level end event exists
          if (!this.tasks[endEventId]) {
            this.tasks[endEventId] = {
              type: 'event',
              eventType: 'end',
              name: 'End',
              id: endEventId,
              lane: null // Process-level event has no lane
            };
            
            // Add to events list
            if (!this.events.includes(endEventId)) {
              this.events.push(endEventId);
            }
          }
          
          // Connect gateway to end event directly with appropriate label
          const branchLabel = branchChar === '+' ? 'Yes' : 'No';
          this.addConnection('flow', parentGateway, endEventId, branchLabel);
          
          return endEventId;
        }
        
        const branchId = `${normalizedLaneName}_${this.normalizeId(branchName)}`;
        
        // Check if this is a special format branch with custom label
        let displayName = branchName;
        let branchLabel = branchChar === '+' ? 'Yes' : 'No';
        
        // Check for custom label format |Label|content
        if (branchName.startsWith('|') && branchName.includes('|', 1)) {
          const labelEnd = branchName.indexOf('|', 1);
          branchLabel = branchName.substring(1, labelEnd);
          displayName = branchName.substring(labelEnd + 1).trim();
        }
        
        this.tasks[branchId] = {
          type: 'branch',
          branchType: branchChar === '+' ? 'positive' : 'negative',
          name: displayName,
          label: branchLabel,
          id: branchId,
          lane: laneName,
          parentGateway: parentGateway
        };
        
        // Add branch to parent gateway
        this.tasks[parentGateway].branches.push(branchId);
        
        // Add to lane
        this.lanes[this.currentLane].tasks.push(branchId);
        
        // Add branch to scope for reference
        const simpleName = this.normalizeId(displayName);
        this.taskScope[simpleName] = branchId;
        this.taskScope[`${laneName}.${simpleName}`] = branchId;
        this.taskScope[`@${laneName}.${simpleName}`] = branchId;
        
        // Note: Connections will be added in connectSequentialTasks() to avoid duplicates
        
        return branchId;
      }

      parseComment(line) {
        if (!this.currentLane) {
          // Create a default lane if needed
          this.parseLane('@Default');
        }
        
        const commentText = line.substring(1).trim();
        const laneName = this.currentLane.replace('@', '');
        const normalizedLaneName = this.normalizeId(laneName);
        const commentId = `${normalizedLaneName}_comment_${this.normalizeId(commentText.substring(0, 20))}`;
        
        this.tasks[commentId] = {
          type: 'comment',
          name: commentText,
          id: commentId,
          lane: laneName
        };
        
        this.lanes[this.currentLane].tasks.push(commentId);
        
        return commentId;
      }

      parseConnection(line) {
        // Format: ^MessageName @Source.task -> @Target.task
        if (line.startsWith('^')) {
          try {
            console.log(`Processing message flow: ${line}`);
            
            // Extract the entire line content after the ^ prefix
            const content = line.substring(1).trim();
            
            // First check for arrow
            let sourcePart, targetPart, messageName, direction;
            
            if (content.includes('->')) {
              [sourcePart, targetPart] = content.split('->').map(s => s.trim());
              direction = 'forward';
            } else if (content.includes('<-')) {
              [targetPart, sourcePart] = content.split('<-').map(s => s.trim());
              direction = 'backward';
            } else {
              // No arrow, assume it's just a message name (old format)
              messageName = content;
              // This is handled differently, return early
              console.log(`Simple message name: ${messageName}`);
              return null;
            }
            
            // Process the source part - first word is the message name if it doesn't contain '@'
            if (sourcePart.includes('@')) {
              // Format is: MessageName @Source.task
              const parts = sourcePart.split(' ');
              messageName = parts[0];
              const sourceRef = parts.slice(1).join(' ');
              console.log(`Complex format - Message: "${messageName}", Source: "${sourceRef}", Target: "${targetPart}"`);
              
              // Resolve source and target
              const sourceId = this.resolveTaskId(sourceRef, false);
              const targetId = this.resolveTaskId(targetPart, false);
              
              if (sourceId && targetId) {
                // Create the message object
                const messageId = `message_${this.normalizeId(messageName)}`;
                
                // Add to messages array if not already there
                if (!this.messages.find(m => m.id === messageId)) {
                  this.messages.push({
                    type: 'message',
                    name: messageName,
                    id: messageId,
                    sourceRef: sourceId,
                    targetRef: targetId
                  });
                  console.log(`Added message: ${messageName} (${messageId})`);
                }
                
                // Check if there's a connection break between these tasks
                const hasBreak = this.hasConnectionBreakBetween(
                  this.taskLineNumbers[sourceId],
                  this.taskLineNumbers[targetId]
                );
                
                if (!hasBreak) {
                  // Create connection in the right direction
                  this.addConnection('message', sourceId, targetId, messageName);
                  console.log(`SUCCESSFULLY added message flow: "${messageName}" from ${sourceId} to ${targetId}`);
                } else {
                  console.log(`Message flow blocked by connection break: "${messageName}" from ${sourceId} to ${targetId}`);
                }
                
                return targetId; // Return the target as the last referenced task
              } else {
                console.error(`Failed to resolve IDs: source="${sourceRef}" (${sourceId || 'null'}), target="${targetPart}" (${targetId || 'null'})`);
              }
            } else {
              // Simple format - source and target are directly provided
              messageName = sourcePart;
              console.log(`Simple format - Message: "${messageName}", Target: "${targetPart}"`);
              
              // Try to find a source (probably the last task)
              const sourceId = this.lastTask;
              const targetId = this.resolveTaskId(targetPart, false);
              
              if (sourceId && targetId) {
                // Create the message object
                const messageId = `message_${this.normalizeId(messageName)}`;
                
                // Add to messages array if not already there
                if (!this.messages.find(m => m.id === messageId)) {
                  this.messages.push({
                    type: 'message',
                    name: messageName,
                    id: messageId,
                    sourceRef: sourceId,
                    targetRef: targetId
                  });
                  console.log(`Added message: ${messageName} (${messageId})`);
                }
                
                this.addConnection('message', sourceId, targetId, messageName);
                console.log(`SUCCESSFULLY added simple message flow: "${messageName}" from ${sourceId} to ${targetId}`);
                return targetId;
              }
            }
          } catch (error) {
            console.error(`Error parsing message flow: ${line}`, error);
          }
        }
        
        return null;
      }

      parseDataObject(line) {
        // Format: #Name task_reference
        try {
          const content = line.substring(1).trim();
          const parts = content.split(' ');
          const name = parts[0];
          const taskRef = parts.slice(1).join(' ');
          
          console.log(`Parsing data object: "${name}", task reference="${taskRef}"`);
          
          const dataObjId = `data_${this.normalizeId(name)}`;
          
          // Create data object even if there's no task reference
          this.dataObjects.push({
            type: 'dataObject',
            name: name,
            id: dataObjId,
            taskRef: taskRef // Store the raw reference
          });
          
          // If task reference can be resolved, create a connection
          if (taskRef) {
            const taskId = this.resolveTaskId(taskRef, false);
            if (taskId) {
              // Create a data association
              this.addConnection('data', dataObjId, taskId);
              console.log(`Added data association from ${dataObjId} to ${taskId}`);
            } else {
              console.log(`Failed to resolve task ID for data object association: "${taskRef}"`);
            }
          }
          
          return dataObjId;
        } catch (error) {
          console.error(`Error parsing data object: ${line}`, error);
          return null;
        }
      }

      addConnection(type, sourceId, targetId, name = '') {
        const connId = `conn_${this.normalizeId(sourceId)}_${this.normalizeId(targetId)}`;
        
        this.connections.push({
          type: type === 'flow' ? 'sequenceFlow' : 
                type === 'message' ? 'messageFlow' : 'dataAssociation',
          id: connId,
          name: name,
          sourceRef: sourceId,
          targetRef: targetId
        });
      }

      injectConnectionBreaksAfterEndEvents(lines) {
        // Find all End event references in the text and auto-inject breaks
        for (let i = 0; i < lines.length; i++) {
          const line = lines[i].trim();
          
          // Check if this line contains an End event reference
          if (line === '!End' || line === '!end' || line === '+!End' || line === '-!End') {
            // Check if there's already a connection break after this line
            const hasBreakAfter = this.connectionBreaks.some(breakLine => 
              breakLine > i && breakLine <= i + 2
            );
            
            if (!hasBreakAfter) {
              // Auto-inject a connection break after this End event
              this.connectionBreaks.push(i + 1);
              console.log(`Auto-injected connection break after End event at line ${i + 1}`);
            }
          }
        }
      }

      connectSequentialTasks() {
        // First build a map of tasks and their sequence
        const gatewayMap = {};
        const gatewayBranchesMap = {};
        
        // Find all gateways and their branches
        Object.values(this.tasks).forEach(task => {
          if (task.type === 'gateway') {
            gatewayMap[task.id] = task;
            gatewayBranchesMap[task.id] = {
              positive: [],
              negative: [],
              nextTask: null
            };
          }
        });
        
        // Collect branches for each gateway
        Object.values(this.tasks).forEach(task => {
          if (task.type === 'branch' && task.parentGateway && gatewayBranchesMap[task.parentGateway]) {
            if (task.branchType === 'positive') {
              gatewayBranchesMap[task.parentGateway].positive.push(task.id);
            } else {
              gatewayBranchesMap[task.parentGateway].negative.push(task.id);
            }
          }
        });
        
        // Connect tasks in sequence within the same lane
        Object.values(this.lanes).forEach(lane => {
          let prevTask = null;
          
          // First find any gateway blocks in this lane
          const gateways = lane.tasks.filter(taskId => 
            this.tasks[taskId] && this.tasks[taskId].type === 'gateway'
          );
          
          // For each gateway, find the next task after it and its branches
          gateways.forEach(gatewayId => {
            const gateway = this.tasks[gatewayId];
            const gatewayIndex = lane.tasks.indexOf(gatewayId);
            
            // Find the first non-branch task after the gateway
            for (let i = gatewayIndex + 1; i < lane.tasks.length; i++) {
              const taskId = lane.tasks[i];
              const task = this.tasks[taskId];
              
              // Skip branches belonging to this gateway
              if (task.type === 'branch' && task.parentGateway === gatewayId) {
                continue;
              }
              
              // Skip other gateways
              if (task.type === 'gateway') {
                continue;
              }
              
              // Found the next task, store it
              gatewayBranchesMap[gatewayId].nextTask = taskId;
              break;
            }
          });
          
          // Now do sequential connections, skipping gateways
          for (let i = 0; i < lane.tasks.length; i++) {
            const currentTaskId = lane.tasks[i];
            const currentTask = this.tasks[currentTaskId];
            
            // Skip branches
            if (currentTask.type === 'branch') {
              continue;
            }
            
            // For gateways, only connect from previous task to the gateway
            if (currentTask.type === 'gateway') {
              if (prevTask) {
                // Connect previous task to gateway
                this.addConnection('flow', prevTask, currentTaskId);
              }
              
              // Don't update prevTask for gateway
              continue;
            }
            
            // Check if this is a task right after a gateway
            let isAfterGateway = false;
            let sourceGateway = null;
            
            for (const [gId, data] of Object.entries(gatewayBranchesMap)) {
              if (data.nextTask === currentTaskId) {
                isAfterGateway = true;
                sourceGateway = gId;
                break;
              }
            }
            
            // If this is a task right after a gateway and has a previous task
            // that's not the gateway, we might need to skip the connection
            if (isAfterGateway && prevTask && !gatewayMap[prevTask]) {
              // Don't connect if it's already connected from the gateway
              const fromGatewayConnections = this.connections.filter(conn =>
                conn.sourceRef === sourceGateway && conn.targetRef === currentTaskId
              );
              
              if (fromGatewayConnections.length > 0) {
                // Skip this connection, it comes from the gateway
                prevTask = currentTaskId;
                continue;
              }
            }
            
            // Connect the previous task to this one if it exists
            if (prevTask) {
              // Check if connection already exists
              const connectionExists = this.connections.some(conn => 
                conn.type === 'sequenceFlow' && 
                conn.sourceRef === prevTask && 
                conn.targetRef === currentTaskId
              );
              
              // Check if there's a connection break between these tasks
              const hasBreak = this.hasConnectionBreakBetween(
                this.taskLineNumbers[prevTask],
                this.taskLineNumbers[currentTaskId]
              );
              
              if (!connectionExists && !hasBreak) {
                this.addConnection('flow', prevTask, currentTaskId);
              }
            }
            
            // Update previous task for next iteration
            prevTask = currentTaskId;
          }
        });
        
        // Now handle branches and gateway connections
        Object.entries(gatewayBranchesMap).forEach(([gatewayId, data]) => {
          const gateway = this.tasks[gatewayId];
          
          // Connect gateway to all branches
          gateway.branches.forEach(branchId => {
            this.addConnection('flow', gatewayId, branchId);
          });
          
          // Connect positive branches to the next task after the gateway
          data.positive.forEach(branchId => {
            const branch = this.tasks[branchId];
            
            // Always connect positive branches to the next task if available
            if (data.nextTask) {
              this.addConnection('flow', branchId, data.nextTask);
            }
          });
          
          // Don't automatically connect negative branches to anything
          // They're dead ends unless explicitly connected
        });
        
        // Connect matching send/receive tasks by message name
        const sendTasks = Object.values(this.tasks).filter(task => task.type === 'send');
        const receiveTasks = Object.values(this.tasks).filter(task => task.type === 'receive');
        
        sendTasks.forEach(sendTask => {
          // Use the message name property, not the full task name
          const messageName = sendTask.messageName;
          
          if (!messageName) return;
          
          // Find matching receive task with the same message name
          const matchingReceive = receiveTasks.find(receiveTask => 
            receiveTask.messageName === messageName
          );
          
          if (matchingReceive) {
            // Check if connection already exists
            const connectionExists = this.connections.some(conn => 
              conn.type === 'messageFlow' && 
              conn.sourceRef === sendTask.id && 
              conn.targetRef === matchingReceive.id
            );
            
            // Check if there's a connection break between these tasks
            const hasBreak = this.hasConnectionBreakBetween(
              this.taskLineNumbers[sendTask.id],
              this.taskLineNumbers[matchingReceive.id]
            );
            
            if (!connectionExists && !hasBreak) {
              // Create the message object
              const messageId = `message_${this.normalizeId(messageName)}`;
              
              // Add to messages array if not already there
              if (!this.messages.find(m => m.id === messageId)) {
                this.messages.push({
                  type: 'message',
                  name: messageName,
                  id: messageId,
                  sourceRef: sendTask.id,
                  targetRef: matchingReceive.id
                });
                console.log(`Added implicit message: ${messageName} (${messageId})`);
              }
              
              this.addConnection('message', sendTask.id, matchingReceive.id, messageName);
            }
          }
        });
        
        // Connect across lanes for tasks that should follow each other
        this.connectAcrossLanes();
        
        // Special handling for start/end events
        this.connectEvents();
      }
      
      connectAcrossLanes() {
        // Get all tasks sorted by their position in the process
        const allLanes = Object.values(this.lanes);
        const allTasksByPosition = [];
        
        // Flatten all tasks, maintaining their order from the lanes
        allLanes.forEach(lane => {
          lane.tasks.forEach(taskId => {
            const task = this.tasks[taskId];
            if (task && task.type !== 'branch') {
              allTasksByPosition.push(task.id);
            }
          });
        });
        
        // Add tasks not explicitly in lanes (if any)
        Object.values(this.tasks).forEach(task => {
          if (!allTasksByPosition.includes(task.id) && task.type !== 'branch') {
            allTasksByPosition.push(task.id);
          }
        });
        
        // Last task of the previous lane should connect to the first task of the next lane
        for (let i = 0; i < allLanes.length - 1; i++) {
          const currentLane = allLanes[i];
          const nextLane = allLanes[i + 1];
          
          // Skip if either lane is empty
          if (currentLane.tasks.length === 0 || nextLane.tasks.length === 0) {
            continue;
          }
          
          // Find the last non-branch task in the current lane
          let lastTaskInCurrentLane = null;
          for (let j = currentLane.tasks.length - 1; j >= 0; j--) {
            const taskId = currentLane.tasks[j];
            const task = this.tasks[taskId];
            if (task && task.type !== 'branch') {
              lastTaskInCurrentLane = taskId;
              break;
            }
          }
          
          // Find the first non-branch task in the next lane
          let firstTaskInNextLane = null;
          for (let j = 0; j < nextLane.tasks.length; j++) {
            const taskId = nextLane.tasks[j];
            const task = this.tasks[taskId];
            if (task && task.type !== 'branch') {
              firstTaskInNextLane = taskId;
              break;
            }
          }
          
          // Connect them if both found
          if (lastTaskInCurrentLane && firstTaskInNextLane) {
            // Check if connection already exists
            const connectionExists = this.connections.some(conn => 
              conn.type === 'sequenceFlow' && 
              conn.sourceRef === lastTaskInCurrentLane && 
              conn.targetRef === firstTaskInNextLane
            );
            
            // Also check if the target task is already connected to from something else
            const targetAlreadyConnected = this.connections.some(conn =>
              conn.type === 'sequenceFlow' &&
              conn.targetRef === firstTaskInNextLane
            );
            
            // Check if there's a connection break between these tasks
            const hasBreak = this.hasConnectionBreakBetween(
              this.taskLineNumbers[lastTaskInCurrentLane],
              this.taskLineNumbers[firstTaskInNextLane]
            );
            
            // Only add if no connection exists, target isn't already connected, and no break
            if (!connectionExists && !targetAlreadyConnected && !hasBreak) {
              this.addConnection('flow', lastTaskInCurrentLane, firstTaskInNextLane);
            }
          }
        }
      }
      
      connectEvents() {
        // Handle process-level Start event connection
        const processStart = this.tasks['process_start'];
        if (processStart) {
          // Find the first task in the entire process
          const firstTask = this.findFirstTaskInProcess();
          if (firstTask) {
            // Check if connection already exists
            const connectionExists = this.connections.some(conn => 
              conn.type === 'sequenceFlow' && 
              conn.sourceRef === 'process_start' && 
              conn.targetRef === firstTask
            );
            
            if (!connectionExists) {
              this.addConnection('flow', 'process_start', firstTask);
            }
          }
        }
        
        // Handle process-level End event connections (already handled by gateway branches and lane connections)
        // Process-level End events are connected by:
        // 1. Gateway branches that end with +!End or -!End
        // 2. Last tasks in lanes that have !End events
        const processEnd = this.tasks['process_end'];
        if (processEnd) {
          // Find tasks that should connect to the process end but aren't already connected
          Object.values(this.tasks).forEach(task => {
            if ((task.type === 'task' || task.type === 'send' || task.type === 'receive') && task.lane) {
              // Check if this task appears to be a final task in its lane
              const lane = this.lanes[`@${task.lane}`];
              if (lane && lane.tasks.length > 0) {
                const lastTaskInLane = lane.tasks[lane.tasks.length - 1];
                // If this is the last task in its lane and there's no outgoing connection
                if (lastTaskInLane === task.id) {
                  const hasOutgoingSequenceFlow = this.connections.some(conn => 
                    conn.sourceRef === task.id && conn.type === 'sequenceFlow'
                  );
                  
                  if (!hasOutgoingSequenceFlow) {
                    // Don't check for connection breaks when connecting to process-level End event
                    // The breaks are meant to prevent OTHER cross-lane connections, not End event connections
                    this.addConnection('flow', task.id, 'process_end');
                  }
                }
              }
            }
          });
        }
      }
      
      findFirstTaskInProcess() {
        // Find the very first task that appears in the process
        // This should be the first non-event task in the first lane that contains tasks
        for (const [laneName, lane] of Object.entries(this.lanes)) {
          for (const taskId of lane.tasks) {
            const task = this.tasks[taskId];
            // Return the first non-event, non-branch task
            if (task && task.type !== 'event' && task.type !== 'branch') {
              return taskId;
            }
          }
        }
        return null;
      }

      resolveTaskId(taskRef, createIfNotFound = false) {
        if (!taskRef) return null;
        
        taskRef = taskRef.trim();
        console.log(`Resolving task ID for: "${taskRef}"`);
        
        // 1. Check direct scope lookup
        if (this.taskScope[taskRef]) {
          console.log(`  Direct lookup success: ${this.taskScope[taskRef]}`);
          return this.taskScope[taskRef];
        }
        
        const normalized = this.normalizeId(taskRef);
        if (this.taskScope[normalized]) {
          console.log(`  Normalized lookup success: ${this.taskScope[normalized]}`);
          return this.taskScope[normalized];
        }
        
        // 2. Check if it's a fully qualified reference (lane.task)
        if (taskRef.includes('.')) {
          const parts = taskRef.split('.');
          
          if (parts.length === 2) {
            let [lane, task] = parts;
            
            if (lane.startsWith('@')) {
              lane = lane.substring(1);
            }
            
            const normalizedTask = this.normalizeId(task);
            
            const lookups = [
              `${lane}.${normalizedTask}`,
              `@${lane}.${normalizedTask}`,
              `${lane}_${normalizedTask}`
            ];
            
            const normalizedLane = this.normalizeId(lane);
            lookups.push(
              `${normalizedLane}.${normalizedTask}`,
              `@${normalizedLane}.${normalizedTask}`,
              `${normalizedLane}_${normalizedTask}`
            );
            
            for (const lookup of lookups) {
              if (this.taskScope[lookup]) {
                console.log(`  Complex lookup success: ${this.taskScope[lookup]} (via ${lookup})`);
                return this.taskScope[lookup];
              }
            }
            
            const directId = `${normalizedLane}_${normalizedTask}`;
            if (this.tasks[directId]) {
              console.log(`  Direct ID lookup success: ${directId}`);
              return directId;
            }
          }
        }
        
        // 3. Search across all lanes in order
        const allLaneNames = Object.keys(this.lanes);
        const currentLaneIndex = this.currentLane ? allLaneNames.indexOf(this.currentLane) : -1;
        
        // 3a. First search in current lane
        if (this.currentLane) {
          const currentLaneName = this.currentLane.replace('@', '');
          const taskInCurrentLane = this.findTaskInLane(currentLaneName, normalized);
          if (taskInCurrentLane) {
            console.log(`  Found in current lane: ${taskInCurrentLane.id}`);
            return taskInCurrentLane.id;
          }
        }
        
        // 3b. Search in previous lanes (going up)
        for (let i = currentLaneIndex - 1; i >= 0; i--) {
          const laneName = allLaneNames[i].replace('@', '');
          const task = this.findTaskInLane(laneName, normalized);
          if (task) {
            console.log(`  Found in previous lane ${laneName}: ${task.id}`);
            return task.id;
          }
        }
        
        // 3c. Search in subsequent lanes (going down)
        for (let i = currentLaneIndex + 1; i < allLaneNames.length; i++) {
          const laneName = allLaneNames[i].replace('@', '');
          const task = this.findTaskInLane(laneName, normalized);
          if (task) {
            console.log(`  Found in subsequent lane ${laneName}: ${task.id}`);
            return task.id;
          }
        }
        
        // 4. If not found and createIfNotFound is true, create implicit task
        if (createIfNotFound && this.currentLane) {
          const implicitTaskId = this.createImplicitTask(taskRef);
          console.log(`  Created implicit task: ${implicitTaskId}`);
          return implicitTaskId;
        }
        
        console.log(`  Resolution failed for: "${taskRef}"`);
        return null;
      }
      
      findTaskInLane(laneName, normalizedTaskName) {
        const laneTasks = Object.values(this.tasks).filter(t => 
          t.lane && t.lane.toLowerCase() === laneName.toLowerCase()
        );
        
        return laneTasks.find(t => 
          this.normalizeId(t.name) === normalizedTaskName || 
          (t.messageName && this.normalizeId(t.messageName) === normalizedTaskName)
        );
      }
      
      createImplicitTask(taskName) {
        if (!this.currentLane) {
          this.parseLane('@Default');
        }
        
        const laneName = this.currentLane.replace('@', '');
        const normalizedLaneName = this.normalizeId(laneName);
        const taskId = `${normalizedLaneName}_${this.normalizeId(taskName)}`;
        
        // Create the implicit task
        this.tasks[taskId] = {
          type: 'task',
          name: taskName,
          id: taskId,
          lane: laneName,
          implicit: true // Mark as implicitly created
        };
        
        // Add to lane tasks
        this.lanes[this.currentLane].tasks.push(taskId);
        
        // Add to scope
        const simpleName = this.normalizeId(taskName);
        this.taskScope[simpleName] = taskId;
        this.taskScope[`${laneName}.${simpleName}`] = taskId;
        this.taskScope[`@${laneName}.${simpleName}`] = taskId;
        
        return taskId;
      }
      
      isSpecialLine(line) {
        if (!line || !line.trim()) return true;
        const firstChar = line.trim().charAt(0);
        return [':', '@', '^', '#', '?', '+', '-', '"', '!', '/'].includes(firstChar);
      }

      normalizeId(name) {
        if (!name) return 'unknown';
        return name.toLowerCase()
          .replace(/[^a-z0-9]+/g, '_')
          .replace(/^_+|_+$/g, '');
      }
      
      hasConnectionBreakBetween(lineNum1, lineNum2) {
        // Check if there's a "---" line between two line numbers
        if (lineNum1 === undefined || lineNum2 === undefined) return false;
        
        const minLine = Math.min(lineNum1, lineNum2);
        const maxLine = Math.max(lineNum1, lineNum2);
        
        // Check if any connection break exists between these lines
        return this.connectionBreaks.some(breakLine => 
          breakLine > minLine && breakLine < maxLine
        );
      }

      toMermaid() {
        // Start with flowchart definition and style classes
        let mermaid = `flowchart TD
  %% Define node styles
  classDef event fill:#ffd,stroke:#33f,stroke-width:2px
  classDef task fill:#bbf,stroke:#33f,stroke-width:2px
  classDef message fill:#bfb,stroke:#070,stroke-width:2px
  classDef gateway fill:#fcc,stroke:#f00,stroke-width:2px
  classDef comment fill:#ffd,stroke:#bb0,stroke-width:1px
  classDef dataObject fill:#ececff,stroke:#9370db,stroke-width:1px
  classDef branch fill:#d5ffd5,stroke:#3cb371,stroke-width:1px
`;

        // Add process-level events (Start/End) outside of any subgraph
        Object.values(this.tasks).forEach(task => {
          if (task.type === 'event' && (task.eventType === 'start' || task.eventType === 'end') && task.lane === null) {
            mermaid += `  ${task.id}([${task.name}]):::event\n`;
          }
        });

        // Add data objects
        this.dataObjects.forEach(dataObj => {
          mermaid += `  ${dataObj.id}[(${dataObj.name})]:::dataObject\n`;
        });

        // Group by lanes/pools
        const laneNodes = {};
        const laneDisplayNames = {};
        
        // Collect nodes for each lane (including branches)
        Object.entries(this.lanes).forEach(([laneName, lane]) => {
          const normalizedLaneName = this.normalizeId(laneName.replace('@', ''));
          laneNodes[normalizedLaneName] = lane.tasks.filter(taskId => {
            const task = this.tasks[taskId];
            return task; // Include all task types in subgraphs
          });
          // Store original lane name for display
          laneDisplayNames[normalizedLaneName] = laneName.replace('@', '');
        });
        
        // Add subgraphs for each lane
        Object.entries(laneNodes).forEach(([laneName, taskIds], index) => {
          if (taskIds.length > 0) {
            // Use sg prefix to ensure valid subgraph names
            const sgName = `sg${index}`;
            // Use the original lane name for display
            const displayName = laneDisplayNames[laneName] || laneName;
            mermaid += `  subgraph ${sgName}["${displayName}"]\n`;
            
            // Add nodes for each task in the lane
            taskIds.forEach(taskId => {
              const task = this.tasks[taskId];
              
              if (!task) return;
              
              switch(task.type) {
                case 'task':
                  mermaid += `    ${task.id}[${task.name}]:::task\n`;
                  break;
                case 'send':
                case 'receive':
                  mermaid += `    ${task.id}>${task.name}]:::message\n`;
                  break;
                case 'gateway':
                  mermaid += `    ${task.id}{${task.name}?}:::gateway\n`;
                  break;
                case 'branch':
                  mermaid += `    ${task.id}["${task.name}"]:::branch\n`;
                  break;
                case 'comment':
                  mermaid += `    ${task.id}[/${task.name}/]:::comment\n`;
                  break;
                case 'event':
                  mermaid += `    ${task.id}([${task.name}]):::event\n`;
                  break;
              }
            });
            
            mermaid += `  end\n`;
          }
        });
        
        // Add branch nodes inside their parent lane subgraphs
        // This is handled in the lane subgraph code already
        
        // Add lane styles
        Object.keys(laneNodes).forEach((laneName, index) => {
          const sgName = `sg${index}`;
          const color = index % 2 === 0 ? 
            'fill:#f9f9f9,stroke:#333,stroke-width:1px' : 
            'fill:#e6f3ff,stroke:#333,stroke-width:1px';
          mermaid += `  style ${sgName} ${color}\n`;
        });
        
        // Add connections
        mermaid += '\n';
        
        // Add normal sequence flows
        mermaid += '  %% Sequence flows\n';
        this.connections.forEach(conn => {
          if (conn.type === 'sequenceFlow') {
            // Check if this is a gateway-to-branch connection or gateway-to-end connection
            const source = this.tasks[conn.sourceRef];
            const target = this.tasks[conn.targetRef];
            
            if (source && target) {
              if (source.type === 'gateway' && target.type === 'branch') {
                // Special formatting for gateway branches with labels
                mermaid += `  ${conn.sourceRef} -->|${target.label}| ${conn.targetRef}\n`;
              } else if (source.type === 'gateway' && target.type === 'event' && target.eventType === 'end') {
                // Gateway to End event with label (from branch)
                const label = conn.name || 'Yes'; // Default to 'Yes' if no label specified
                mermaid += `  ${conn.sourceRef} -->|${label}| ${conn.targetRef}\n`;
              } else {
                mermaid += `  ${conn.sourceRef} --> ${conn.targetRef}\n`;
              }
            }
          }
        });
        
        // Add message flows with dashed lines and labels
        mermaid += '  %% Message flows\n';
        this.connections.forEach(conn => {
          if (conn.type === 'messageFlow') {
            const label = conn.name ? `|${conn.name}|` : '';
            mermaid += `  ${conn.sourceRef} -.->${ label } ${conn.targetRef}\n`;
          }
        });
        
        // Add data associations with dashed lines
        mermaid += '  %% Data flows\n';
        this.connections.forEach(conn => {
          if (conn.type === 'dataAssociation') {
            mermaid += `  ${conn.sourceRef} -.-> ${conn.targetRef}\n`;
          }
        });
        
        return mermaid;
      }
    }
  </script>
  
  <!-- Gateway Test Cases -->
  <script>
    function runGatewayTests() {
      // Test case 1: Simple XOR gateway
      const xorGatewayTest = `:XOR Gateway Test
@Lane1
  start task
  ?Simple Decision
    +yes path
    -no path
  end task`;
      
      // Test case 2: Complex gateway with custom labels
      const complexGatewayTest = `:Complex Gateway Test
@Lane1
  start task
  ?Payment Method
    +|Credit Card| process credit card
    +|Bank Transfer| process bank transfer
    -|Cancel| cancel order
  next task`;
      
      // Test case 3: Nested gateways
      const nestedGatewayTest = `:Nested Gateway Test
@Lane1
  start task
  ?First Decision
    +?Nested Decision
      +nested yes
      -nested no
    -no path
  end task`;
      
      // Run tests and display results
      const testCases = [
        { name: "Simple XOR Gateway", dsl: xorGatewayTest },
        { name: "Complex Gateway with Custom Labels", dsl: complexGatewayTest },
        { name: "Nested Gateways", dsl: nestedGatewayTest }
      ];
      
      const testResults = testCases.map(test => {
        try {
          const parser = new BpmnLiteParser();
          const ast = parser.parse(test.dsl);
          const mermaid = parser.toMermaid();
          
          // Check for essential elements in AST
          const hasGateway = Object.values(parser.tasks).some(task => task.type === 'gateway');
          const hasBranches = Object.values(parser.tasks).some(task => task.type === 'branch');
          
          return {
            name: test.name,
            success: hasGateway && hasBranches,
            ast: ast,
            mermaid: mermaid
          };
        } catch (error) {
          return {
            name: test.name,
            success: false,
            error: error.message
          };
        }
      });
      
      console.log("Gateway Test Results:", testResults);
      return testResults;
    }
    
    // Run tests after page loads
    window.addEventListener('load', () => {
      console.log("%c BPMN-lite Parser Demo v2.0.0 (2025-04-18 21:30) LOADED", "background: yellow; color: black; font-size: 20px");
      const testResults = runGatewayTests();
      console.log("Gateway tests completed, check console for results");
      
      // Add test output to UI for easy visibility
      setTimeout(() => {
        const outputDiv = document.createElement('div');
        outputDiv.style.position = 'fixed';
        outputDiv.style.bottom = '10px';
        outputDiv.style.right = '10px';
        outputDiv.style.backgroundColor = 'yellow';
        outputDiv.style.padding = '10px';
        outputDiv.style.zIndex = '1000';
        outputDiv.style.border = '2px solid black';
        outputDiv.innerHTML = `Version: v2.0.0 (2025-04-18 21:30)<br>
                              Test Results: ${testResults.filter(t => t.success).length}/${testResults.length} passed<br>
                              Live Diagram Rendering Enabled!`;
        document.body.appendChild(outputDiv);
      }, 2000);
    });
  </script>
</head>
<body>
  <header>
    <div class="title">BPMN-lite Parser Demo v2.0.0 (2025-04-18 21:30)</div>
    <div id="version-marker" style="background-color: yellow; color: black; padding: 5px; font-weight: bold;">LIVE DIAGRAM RENDERING ENABLED!</div>
  </header>
  
  <div class="main-container">
    <div class="editor-container">
      <textarea id="code-editor" spellcheck="false"></textarea>
      <div class="editor-controls">
        <button id="parse-button">Parse DSL</button>
        <button id="render-button">Render Diagram</button>
        <div class="save-controls">
          <button id="save-bpl">Save .bpl</button>
          <button id="save-ast">Save .json</button>
          <button id="save-mmd">Save .mmd</button>
          <button id="save-xlsx">Save .xlsx</button>
        </div>
      </div>
    </div>
    <div class="preview-container">
      <div class="preview-tabs">
        <div class="preview-tab active" data-tab="diagram">Diagram</div>
        <div class="preview-tab" data-tab="ast">AST</div>
        <div class="preview-tab" data-tab="mermaid">Mermaid Code</div>
      </div>
      <div id="error-container" class="error"></div>
      <div id="diagram-preview" class="preview-content active">
        <div class="controls" id="diagram-controls" style="display: none;">
          <div class="export-menu" id="exportMenu">
            <button onclick="toggleExportMenu()" title="Export Options"> Export</button>
            <div class="export-dropdown">
              <button onclick="exportPNG()" title="Export as PNG"> PNG Image</button>
              <button onclick="exportSVG()" title="Export as SVG"> SVG Vector</button>
              <button onclick="exportMermaid()" title="Export as Mermaid"> Mermaid Code</button>
              <button onclick="exportXLSX()" title="Export for Visio"> Excel (Visio)</button>
              <button onclick="exportBPMN()" title="Export as BPMN"> BPMN XML</button>
            </div>
          </div>
        </div>
        <div id="mermaid-preview" class="mermaid-preview"></div>
      </div>
      <div id="ast-preview" class="preview-content ast-preview"></div>
      <div id="mermaid-code-preview" class="preview-content ast-preview"></div>
    </div>
  </div>
  
  <script>
    // Initialize Mermaid
    mermaid.initialize({
      startOnLoad: true,
      theme: 'default',
      securityLevel: 'loose',
      flowchart: {
        useMaxWidth: false,
        htmlLabels: true,
        curve: 'basis'
      }
    });
    
    // File handling utilities
    function saveFile(content, filename) {
      const blob = new Blob([content], { type: 'text/plain' });
      const url = URL.createObjectURL(blob);
      
      const a = document.createElement('a');
      a.href = url;
      a.download = filename;
      document.body.appendChild(a);
      a.click();
      
      // Cleanup
      setTimeout(() => {
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
      }, 100);
    }
    
    // Function to format and normalize BPL content
    function formatBplContent(content) {
      // Split into lines, trim each line
      const lines = content.split('\n').map(line => line.trim());
      
      // Remove empty lines from the beginning and end
      let start = 0;
      let end = lines.length - 1;
      
      while (start < lines.length && !lines[start]) start++;
      while (end >= 0 && !lines[end]) end--;
      
      // Get only the non-empty part
      const cleanLines = lines.slice(start, end + 1);
      
      // Add consistent spacing and ensure proper formatting
      let formattedContent = '';
      let currentLane = null;
      
      for (let i = 0; i < cleanLines.length; i++) {
        const line = cleanLines[i];
        
        // Process definition starts with :
        if (line.startsWith(':')) {
          formattedContent += line + '\n\n';
        }
        // Lane definition starts with @
        else if (line.startsWith('@')) {
          if (i > 0) formattedContent += '\n';
          formattedContent += line + '\n';
          currentLane = line;
        }
        // Regular task or action (add indentation)
        else {
          formattedContent += '  ' + line + '\n';
        }
      }
      
      return formattedContent;
    }

    // Sample DSL
    const sampleDSL = `:Order Process

@Customer
  place order
  send: Payment Information
  "Customer waits for confirmation
  receive: Order Confirmation

@System
  receive: Payment Information
  process order
  validate payment
  ?Payment successful
    +post payment
    -stop order processing
  ship order
  send: Order Confirmation

^Order @Customer.place order -> @System.process order
#OrderData place order`;

    // Current state
    let currentAst = null;
    let currentMermaid = null;
    
    // Debounce function to limit the rate of function calls
    function debounce(func, wait) {
      let timeout;
      return function() {
        const context = this;
        const args = arguments;
        clearTimeout(timeout);
        timeout = setTimeout(() => func.apply(context, args), wait);
      };
    }

    // DOM elements
    const codeEditor = document.getElementById('code-editor');
    const parseButton = document.getElementById('parse-button');
    const renderButton = document.getElementById('render-button');
    const mermaidPreview = document.getElementById('mermaid-preview');
    const astPreview = document.getElementById('ast-preview');
    const mermaidCodePreview = document.getElementById('mermaid-code-preview');
    const errorContainer = document.getElementById('error-container');
    const tabs = document.querySelectorAll('.preview-tab');
    const previewContents = document.querySelectorAll('.preview-content');
    
    // Set sample code
    codeEditor.value = sampleDSL;
    
    // Tab switching
    tabs.forEach(tab => {
      tab.addEventListener('click', () => {
        const tabName = tab.getAttribute('data-tab');
        
        // Update active tab
        tabs.forEach(t => t.classList.remove('active'));
        tab.classList.add('active');
        
        // Show/hide corresponding content
        previewContents.forEach(content => {
          content.classList.remove('active');
        });
        
        if (tabName === 'diagram') {
          document.getElementById('diagram-preview').classList.add('active');
        } else if (tabName === 'ast') {
          document.getElementById('ast-preview').classList.add('active');
        } else if (tabName === 'mermaid') {
          document.getElementById('mermaid-code-preview').classList.add('active');
        }
      });
    });
    
    // Parse function
    function parseDSL() {
      try {
        const parser = new BpmnLiteParser();
        currentAst = parser.parse(codeEditor.value);
        currentMermaid = parser.toMermaid();
        
        // Display AST
        astPreview.textContent = JSON.stringify(currentAst, null, 2);
        
        // Display Mermaid code
        mermaidCodePreview.textContent = currentMermaid;
        
        // Hide error
        errorContainer.style.display = 'none';
        
        return true;
      } catch (error) {
        errorContainer.textContent = `Error parsing DSL: ${error.message || 'Unknown error'}`;
        errorContainer.style.display = 'block';
        
        console.error('Error parsing DSL:', error);
        return false;
      }
    }
    
    // Render function
    function renderDiagram() {
      // Parse first if needed
      if (!currentMermaid) {
        if (!parseDSL()) return;
      }
      
      if (currentMermaid) {
        try {
          // Clear previous diagram
          mermaidPreview.innerHTML = '';
          
          // Create a unique ID for the diagram
          const diagramId = 'mermaid-diagram-' + Date.now();
          
          // Create a div for the diagram
          const diagramDiv = document.createElement('div');
          diagramDiv.className = 'mermaid';
          diagramDiv.id = diagramId;
          diagramDiv.textContent = currentMermaid;
          
          // Add to the preview container
          mermaidPreview.appendChild(diagramDiv);
          
          // Render using Mermaid
          mermaid.render(diagramId, currentMermaid)
            .then(result => {
              // Replace with the rendered SVG
              mermaidPreview.innerHTML = result.svg;
              
              // Add some styling for better display
              const svg = mermaidPreview.querySelector('svg');
              if (svg) {
                svg.style.maxWidth = '100%';
                svg.style.height = 'auto';
                svg.style.display = 'block';
                svg.style.margin = '0 auto';
              }
            })
            .catch(error => {
              console.error('Mermaid rendering error:', error);
              errorContainer.textContent = `Error rendering diagram: ${error.message || 'Unknown error'}`;
              errorContainer.style.display = 'block';
            });
          
          // Hide error if successful
          errorContainer.style.display = 'none';
          
          // Show export controls
          const controls = document.getElementById('diagram-controls');
          if (controls) {
            controls.style.display = 'flex';
          }
        } catch (error) {
          errorContainer.textContent = `Error displaying Mermaid diagram: ${error.message || 'Unknown error'}`;
          errorContainer.style.display = 'block';
          
          console.error('Error displaying Mermaid diagram:', error);
        }
      }
    }
    
    // Live updating - debounced to avoid excessive updates
    const updatePreview = debounce(() => {
      parseDSL();
      renderDiagram();
    }, 300);
    
    // Add input event listener for live updates
    codeEditor.addEventListener('input', updatePreview);
    
    // Parse button
    parseButton.addEventListener('click', () => {
      parseDSL();
    });
    
    // Render button
    renderButton.addEventListener('click', () => {
      renderDiagram();
    });
    
    // Initial parse and render
    setTimeout(() => {
      parseDSL();
      renderDiagram();
    }, 100);
    
    // Export menu toggle
    function toggleExportMenu() {
      const menu = document.getElementById('exportMenu');
      menu.classList.toggle('active');
    }
    
    // Close dropdown when clicking outside
    window.addEventListener('click', function(event) {
      if (!event.target.matches('#exportMenu button')) {
        const menu = document.getElementById('exportMenu');
        if (menu && menu.classList.contains('active')) {
          menu.classList.remove('active');
        }
      }
    });
    
    // Export functions
    function exportPNG() {
      const svgElement = document.querySelector('#mermaid-preview svg');
      if (!svgElement) {
        alert('No diagram to export');
        return;
      }
      
      // For now, export as SVG with PNG extension
      const svgData = new XMLSerializer().serializeToString(svgElement);
      const svgBlob = new Blob([svgData], {type: 'image/svg+xml;charset=utf-8'});
      const svgUrl = URL.createObjectURL(svgBlob);
      const downloadLink = document.createElement('a');
      downloadLink.href = svgUrl;
      downloadLink.download = getProcessName(codeEditor.value) + '.svg';
      document.body.appendChild(downloadLink);
      downloadLink.click();
      document.body.removeChild(downloadLink);
    }
    
    function exportSVG() {
      const svgElement = document.querySelector('#mermaid-preview svg');
      if (!svgElement) {
        alert('No diagram to export');
        return;
      }
      
      const svgData = new XMLSerializer().serializeToString(svgElement);
      saveFile(svgData, getProcessName(codeEditor.value) + '.svg');
    }
    
    function exportMermaid() {
      if (!currentMermaid) {
        alert('No Mermaid code to export');
        return;
      }
      
      saveFile(currentMermaid, getProcessName(codeEditor.value) + '.mmd');
    }
    
    function exportXLSX() {
      if (!currentAst) {
        alert('No AST to export. Please parse the diagram first.');
        return;
      }
      
      const jsonContent = JSON.stringify(currentAst, null, 2);
      saveFile(jsonContent, getProcessName(codeEditor.value) + '-ast.json');
      alert('AST saved as JSON. Use the ast_to_visio.py tool to convert to XLSX format.');
    }
    
    function exportBPMN() {
      if (!currentAst) {
        alert('No AST to export. Please parse the diagram first.');
        return;
      }
      
      const bpmnXml = astToBPMN(currentAst);
      saveFile(bpmnXml, getProcessName(codeEditor.value) + '.bpmn');
    }
    
    function astToBPMN(ast) {
      // Basic BPMN 2.0 XML structure
      let bpmn = `<?xml version="1.0" encoding="UTF-8"?>
<bpmn:definitions xmlns:bpmn="http://www.omg.org/spec/BPMN/20100524/MODEL"
                  xmlns:bpmndi="http://www.omg.org/spec/BPMN/20100524/DI"
                  xmlns:dc="http://www.omg.org/spec/DD/20100524/DC"
                  xmlns:di="http://www.omg.org/spec/DD/20100524/DI"
                  xmlns:camunda="http://camunda.org/schema/1.0/bpmn"
                  id="Definitions_1" targetNamespace="http://bpmn.io/schema/bpmn">
`;
      
      // Process each process in the AST
      ast.processes?.forEach((process) => {
        bpmn += `  <bpmn:process id="${process.id}" name="${process.name}" isExecutable="true">\n`;
        
        // Add lanes as swimlanes
        process.lanes?.forEach((lane) => {
          lane.elements?.forEach((element) => {
            switch (element.type) {
              case 'task':
                bpmn += `    <bpmn:task id="${element.id}" name="${element.name}" />\n`;
                break;
              case 'event':
                if (element.eventType === 'start') {
                  bpmn += `    <bpmn:startEvent id="${element.id}" name="${element.name}" />\n`;
                } else if (element.eventType === 'end') {
                  bpmn += `    <bpmn:endEvent id="${element.id}" name="${element.name}" />\n`;
                } else {
                  bpmn += `    <bpmn:intermediateThrowEvent id="${element.id}" name="${element.name}" />\n`;
                }
                break;
              case 'gateway':
                bpmn += `    <bpmn:exclusiveGateway id="${element.id}" name="${element.name}" />\n`;
                break;
              case 'send':
                bpmn += `    <bpmn:sendTask id="${element.id}" name="${element.name}" />\n`;
                break;
              case 'receive':
                bpmn += `    <bpmn:receiveTask id="${element.id}" name="${element.name}" />\n`;
                break;
            }
          });
        });
        
        // Add sequence flows
        ast.connections?.filter(c => c.type === 'sequenceFlow').forEach((conn) => {
          bpmn += `    <bpmn:sequenceFlow id="${conn.id}" sourceRef="${conn.sourceRef}" targetRef="${conn.targetRef}" />\n`;
        });
        
        bpmn += `  </bpmn:process>\n`;
      });
      
      // Add message flows
      ast.connections?.filter(c => c.type === 'messageFlow').forEach((conn) => {
        bpmn += `  <bpmn:messageFlow id="${conn.id}" sourceRef="${conn.sourceRef}" targetRef="${conn.targetRef}" name="${conn.name || ''}" />\n`;
      });
      
      bpmn += `</bpmn:definitions>`;
      return bpmn;
    }
    
    // Save buttons functionality
    const saveBplButton = document.getElementById('save-bpl');
    const saveAstButton = document.getElementById('save-ast');
    const saveMmdButton = document.getElementById('save-mmd');
    const saveXlsxButton = document.getElementById('save-xlsx');
    
    // Get derived process name from BPL content
    function getProcessName(content) {
      // Look for a process definition line ":Process Name"
      const processLine = content.split('\n').find(line => line.trim().startsWith(':'));
      if (processLine) {
        return processLine.substring(1).trim().replace(/[^a-zA-Z0-9_]/g, '_').toLowerCase();
      }
      
      // Default name if no process defined
      return 'business_process';
    }
    
    // Save BPL file handler
    saveBplButton.addEventListener('click', () => {
      const formattedContent = formatBplContent(codeEditor.value);
      const processName = getProcessName(codeEditor.value);
      saveFile(formattedContent, `${processName}.bpl`);
    });
    
    // Save AST JSON file handler
    saveAstButton.addEventListener('click', () => {
      if (!currentAst) {
        parseDSL();
      }
      
      if (currentAst) {
        const processName = getProcessName(codeEditor.value);
        const jsonContent = JSON.stringify(currentAst, null, 2);
        saveFile(jsonContent, `${processName}-ast.json`);
      } else {
        alert('Error: Unable to generate AST. Please check your BPL syntax.');
      }
    });
    
    // Save Mermaid file handler
    saveMmdButton.addEventListener('click', () => {
      if (!currentMermaid) {
        parseDSL();
      }
      
      if (currentMermaid) {
        const processName = getProcessName(codeEditor.value);
        saveFile(currentMermaid, `${processName}.mmd`);
      } else {
        alert('Error: Unable to generate Mermaid diagram. Please check your BPL syntax.');
      }
    });
    
    // Save Excel file handler (frontend only - simulates the backend call)
    saveXlsxButton.addEventListener('click', () => {
      if (!currentAst) {
        parseDSL();
      }
      
      if (currentAst) {
        const processName = getProcessName(codeEditor.value);
        
        // In a real backend environment, we would call our Python tool here.
        // For client-side only, we'll show a message explaining what would happen.
        alert(
          "In a server environment, this would call:\n" +
          `python tools/ast_to_visio.py ${processName}-ast.json ${processName}.xlsx\n\n` +
          "Since this is browser-only, we've saved the AST JSON which you can process manually."
        );
        
        // Save the JSON as fallback for browser-based usage
        const jsonContent = JSON.stringify(currentAst, null, 2);
        saveFile(jsonContent, `${processName}-ast.json`);
      } else {
        alert('Error: Unable to generate AST for Excel export. Please check your BPL syntax.');
      }
    });
  </script>

  <!-- Electron integration script -->
  <script>
    // Check if we're running in Electron
    const isElectron = typeof window.api !== 'undefined';
    
    if (isElectron) {
      console.log('Running in Electron environment');
      
      // Handle file open events from the main process
      window.api.handleFileOpen((content) => {
        codeEditor.value = content;
        updatePreview();
      });
      
      // Handle new file events
      window.api.handleNewFile(() => {
        codeEditor.value = '';
        updatePreview();
      });
      
      // Handle requests for the AST for Excel export
      window.api.handleAstRequest((outputPath) => {
        // Make sure we have a current AST
        if (!currentAst) {
          parseDSL();
        }
        
        if (currentAst) {
          window.api.exportToExcel(currentAst, outputPath);
        }
      });
      
      // Modify save behavior in Electron environment
      document.getElementById('save-xlsx').addEventListener('click', (originalEvent) => {
        if (isElectron) {
          // Prevent default web behavior when in Electron
          originalEvent.stopPropagation();
          originalEvent.preventDefault();
          
          // Let Electron handle the Excel export through the menu
          // The main process will trigger the handleAstRequest event
        }
      });
    }
  </script>
</body>
</html>