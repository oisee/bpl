<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>BPMN-lite Parser Demo</title>
  <style>
    body {
      font-family: Arial, sans-serif;
      margin: 0;
      padding: 0;
      display: flex;
      flex-direction: column;
      height: 100vh;
      overflow: hidden;
    }
    
    header {
      background-color: #333;
      color: white;
      padding: 10px;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }
    
    .title {
      font-size: 1.2em;
      font-weight: bold;
    }
    
    .main-container {
      display: flex;
      flex: 1;
      overflow: hidden;
    }
    
    .editor-container {
      flex: 1;
      height: 100%;
      border-right: 1px solid #ccc;
      display: flex;
      flex-direction: column;
      padding: 10px;
    }
    
    #code-editor {
      width: 100%;
      height: calc(100% - 50px);
      font-family: monospace;
      font-size: 14px;
      resize: none;
      padding: 10px;
      box-sizing: border-box;
      border: 1px solid #ccc;
      border-radius: 4px;
    }
    
    .editor-controls {
      margin-top: 10px;
      display: flex;
      justify-content: flex-end;
      gap: 10px;
    }
    
    .preview-container {
      flex: 1;
      height: 100%;
      overflow: auto;
      padding: 10px;
      display: flex;
      flex-direction: column;
    }
    
    .preview-tabs {
      display: flex;
      border-bottom: 1px solid #ccc;
      margin-bottom: 10px;
    }
    
    .preview-tab {
      padding: 5px 10px;
      cursor: pointer;
      border: 1px solid transparent;
    }
    
    .preview-tab.active {
      border: 1px solid #ccc;
      border-bottom: none;
      background-color: white;
    }
    
    .preview-content {
      flex: 1;
      overflow: auto;
      display: none;
    }
    
    .preview-content.active {
      display: block;
    }
    
    .ast-preview {
      font-family: monospace;
      white-space: pre-wrap;
      padding: 10px;
      background-color: #f5f5f5;
      border-radius: 4px;
      overflow: auto;
      height: 100%;
    }
    
    .mermaid-preview {
      height: 100%;
      display: flex;
      justify-content: center;
      align-items: center;
    }
    
    .error {
      color: red;
      padding: 10px;
      background-color: #ffeeee;
      border-radius: 4px;
      margin-bottom: 10px;
      display: none;
    }
    
    button {
      padding: 5px 10px;
      background-color: #4CAF50;
      color: white;
      border: none;
      border-radius: 4px;
      cursor: pointer;
    }
    
    button:hover {
      background-color: #45a049;
    }
  </style>
  <script>
    class BpmnLiteParser {
      constructor() {
        this.processes = [];
        this.lanes = {};
        this.tasks = {};
        this.connections = [];
        this.dataObjects = [];
        this.currentProcess = null;
        this.currentLane = null;
        this.lastTask = null;
        this.taskScope = {};
        this.gatewayStack = [];
      }

      parse(text) {
        // Reset state
        this.processes = [];
        this.lanes = {};
        this.tasks = {};
        this.connections = [];
        this.dataObjects = [];
        this.currentProcess = null;
        this.currentLane = null;
        this.lastTask = null;
        this.taskScope = {};
        this.gatewayStack = [];

        const lines = text.split('\n');
        
        // Create default process if none specified
        this.ensureProcess("Default Process");
        
        // First pass: collect processes, lanes, and tasks
        for (let i = 0; i < lines.length; i++) {
          const originalLine = lines[i];
          const line = originalLine.trim();
          if (!line) continue; // Skip empty lines
          
          // Find first non-whitespace character for line type detection
          const firstNonWhitespace = line.match(/\S/);
          if (!firstNonWhitespace) continue;
          
          const firstChar = firstNonWhitespace[0];
          
          // Check for connected parts with -> or <- operators
          const parts = this.splitConnections(line);
          
          if (parts.length > 1) {
            // Process each part and create the connections
            let prevTaskId = null;
            
            for (let j = 0; j < parts.length; j++) {
              const part = parts[j].trim();
              if (!part) continue;
              
              // Process this part
              const taskId = this.processLinePart(part, firstChar);
              
              // Create connection if we have a previous task
              if (prevTaskId && taskId) {
                const connectionType = parts[j-1].includes('<-') ? 'backward' : 'forward';
                
                if (connectionType === 'forward') {
                  this.addConnection('flow', prevTaskId, taskId);
                } else {
                  this.addConnection('flow', taskId, prevTaskId);
                }
              }
              
              if (taskId) {
                prevTaskId = taskId;
              }
            }
          } else {
            // Single part, process normally
            this.processLinePart(line, firstChar);
          }
        }

        // Automatically connect sequential tasks within lanes
        this.connectSequentialTasks();

        // Build the AST
        const ast = {
          type: 'bpmnModel',
          processes: this.processes.map(processName => ({
            type: 'process',
            name: processName,
            id: this.normalizeId(processName),
            lanes: Object.entries(this.lanes)
              .filter(([_, lane]) => lane.process === processName)
              .map(([laneName, lane]) => ({
                type: 'lane',
                name: laneName.replace('@', ''),
                id: this.normalizeId(laneName),
                elements: lane.tasks.map(taskId => this.tasks[taskId])
              }))
          })),
          connections: this.connections,
          dataObjects: this.dataObjects
        };

        return ast;
      }
      
      splitConnections(line) {
        // Split the line at -> and <- operators, preserving the operators
        const result = [];
        let currentPart = '';
        let i = 0;
        
        while (i < line.length) {
          if (line.substr(i, 2) === '->' || line.substr(i, 2) === '<-') {
            result.push(currentPart);
            result.push(line.substr(i, 2));
            currentPart = '';
            i += 2;
          } else {
            currentPart += line[i];
            i++;
          }
        }
        
        if (currentPart) {
          result.push(currentPart);
        }
        
        // Rejoin into proper parts that maintain the operator with the right part
        const parts = [];
        for (let i = 0; i < result.length; i++) {
          if (result[i] === '->' || result[i] === '<-') {
            parts[parts.length - 1] += result[i];
          } else {
            parts.push(result[i]);
          }
        }
        
        return parts;
      }
      
      processLinePart(line, firstChar) {
        // Process based on the first character
        let taskId = null;
        
        switch(firstChar) {
          case ':': // Process definition
            this.parseProcess(line);
            break;
          case '@': // Lane definition
            this.parseLane(line);
            break;
          case '^': // Message flow
            taskId = this.parseConnection(line);
            break;
          case '#': // Data object
            taskId = this.parseDataObject(line);
            break;
          case '?': // Gateway
            taskId = this.parseGateway(line);
            break;
          case '+': // Positive branch
          case '-': // Negative branch
            taskId = this.parseGatewayBranch(line, firstChar);
            break;
          case '"': // Comment
            taskId = this.parseComment(line);
            break;
          case '/': // Technical comment (ignored)
            if (line.startsWith('//')) {
              // Ignore technical comments
              break;
            }
            // If not a comment, treat as a task
            taskId = this.parseTask(line);
            break;
          default:
            // Check if this is a task
            taskId = this.parseTask(line);
        }
        
        // Update last task if we created one
        if (taskId) {
          this.lastTask = taskId;
        }
        
        return taskId;
      }

      ensureProcess(name) {
        if (!this.processes.includes(name)) {
          this.processes.push(name);
          this.currentProcess = name;
        }
      }

      parseProcess(line) {
        const processName = line.substring(1).trim();
        this.ensureProcess(processName);
      }

      parseLane(line) {
        const laneName = line.trim();
        if (!this.lanes[laneName]) {
          this.lanes[laneName] = {
            process: this.currentProcess,
            tasks: []
          };
        }
        this.currentLane = laneName;
        this.lastTask = null; // Reset last task when changing lanes
      }

      parseTask(line) {
        if (!this.currentLane) {
          // Create a default lane if needed
          this.parseLane('@Default');
        }
        
        // Already trimmed the line in the main parse method
        if (!line) return null;
        
        let taskType = 'task';
        let taskName = line;
        let originalName = line; // Keep the original name for display
        
        // Check task type based on prefix
        if (line.startsWith('send:')) {
          taskType = 'send';
          taskName = line.substring(5).trim(); // Extract just the message name
          originalName = `send: ${taskName}`; // Keep the "send:" prefix in display name
        } else if (line.startsWith('receive:')) {
          taskType = 'receive';
          taskName = line.substring(8).trim(); // Extract just the message name
          originalName = `receive: ${taskName}`; // Keep the "receive:" prefix in display name
        }
        
        const laneName = this.currentLane.replace('@', '');
        const taskId = `${laneName}_${this.normalizeId(originalName)}`; // Use normalized version of full name
        
        this.tasks[taskId] = {
          type: taskType,
          name: originalName, // Use original name with prefix for display
          messageName: taskType === 'send' || taskType === 'receive' ? taskName : null, // Store message name separately
          id: taskId,
          lane: laneName
        };
        
        this.lanes[this.currentLane].tasks.push(taskId);
        
        // Add task to scope for reference in connections
        // Use simplified name without prefixes for lookup
        const simpleName = this.normalizeId(taskName);
        this.taskScope[simpleName] = taskId;
        this.taskScope[`${laneName}.${simpleName}`] = taskId;
        this.taskScope[`@${laneName}.${simpleName}`] = taskId;
        
        // Also add the full name with prefix for reference
        const fullName = this.normalizeId(originalName);
        this.taskScope[fullName] = taskId;
        this.taskScope[`${laneName}.${fullName}`] = taskId;
        this.taskScope[`@${laneName}.${fullName}`] = taskId;
        
        return taskId;
      }

      parseGateway(line) {
        if (!this.currentLane) {
          // Create a default lane if needed
          this.parseLane('@Default');
        }
        
        const gatewayName = line.substring(1).trim();
        const laneName = this.currentLane.replace('@', '');
        const gatewayId = `${laneName}_${this.normalizeId(gatewayName)}`;
        
        this.tasks[gatewayId] = {
          type: 'gateway',
          gatewayType: 'exclusive',
          name: gatewayName,
          id: gatewayId,
          lane: laneName,
          branches: []
        };
        
        this.lanes[this.currentLane].tasks.push(gatewayId);
        
        // Add gateway to scope for reference
        const simpleName = this.normalizeId(gatewayName);
        this.taskScope[simpleName] = gatewayId;
        this.taskScope[`${laneName}.${simpleName}`] = gatewayId;
        this.taskScope[`@${laneName}.${simpleName}`] = gatewayId;
        
        // Push to gateway stack
        this.gatewayStack.push(gatewayId);
        
        return gatewayId;
      }

      parseGatewayBranch(line, branchChar) {
        if (this.gatewayStack.length === 0) {
          // No gateway to attach to
          return null;
        }
        
        const parentGateway = this.gatewayStack[this.gatewayStack.length - 1];
        const branchName = line.substring(1).trim();
        const laneName = this.currentLane.replace('@', '');
        const branchId = `${laneName}_${this.normalizeId(branchName)}`;
        
        // Check if this is a special format branch with custom label
        let displayName = branchName;
        let branchLabel = branchChar === '+' ? 'Yes' : 'No';
        
        // Check for custom label format |Label|content
        if (branchName.startsWith('|') && branchName.includes('|', 1)) {
          const labelEnd = branchName.indexOf('|', 1);
          branchLabel = branchName.substring(1, labelEnd);
          displayName = branchName.substring(labelEnd + 1).trim();
        }
        
        this.tasks[branchId] = {
          type: 'branch',
          branchType: branchChar === '+' ? 'positive' : 'negative',
          name: displayName,
          label: branchLabel,
          id: branchId,
          lane: laneName,
          parentGateway: parentGateway
        };
        
        // Add branch to parent gateway
        this.tasks[parentGateway].branches.push(branchId);
        
        // Add to lane
        this.lanes[this.currentLane].tasks.push(branchId);
        
        // Add branch to scope for reference
        const simpleName = this.normalizeId(displayName);
        this.taskScope[simpleName] = branchId;
        this.taskScope[`${laneName}.${simpleName}`] = branchId;
        this.taskScope[`@${laneName}.${simpleName}`] = branchId;
        
        // Connect gateway to this branch
        this.addConnection('flow', parentGateway, branchId);
        
        return branchId;
      }

      parseComment(line) {
        if (!this.currentLane) {
          // Create a default lane if needed
          this.parseLane('@Default');
        }
        
        const commentText = line.substring(1).trim();
        const laneName = this.currentLane.replace('@', '');
        const commentId = `${laneName}_comment_${this.normalizeId(commentText.substring(0, 20))}`;
        
        this.tasks[commentId] = {
          type: 'comment',
          name: commentText,
          id: commentId,
          lane: laneName
        };
        
        this.lanes[this.currentLane].tasks.push(commentId);
        
        return commentId;
      }

      parseConnection(line) {
        // Format: ^Name source -> target
        if (line.startsWith('^')) {
          const parts = line.substring(1).trim().split(' ');
          const name = parts[0];
          
          // Find the arrow index
          let arrowIndex = -1;
          for (let i = 0; i < parts.length; i++) {
            if (parts[i] === '->' || parts[i] === '<-') {
              arrowIndex = i;
              break;
            }
          }
          
          if (arrowIndex === -1) {
            // No arrow found, but this could be a standalone message
            return null;
          }
          
          const source = parts.slice(1, arrowIndex).join(' ');
          const target = parts.slice(arrowIndex + 1).join(' ');
          const connectionType = parts[arrowIndex] === '<-' ? 'backward' : 'forward';
          
          const sourceId = this.resolveTaskId(source);
          const targetId = this.resolveTaskId(target);
          
          if (sourceId && targetId) {
            if (connectionType === 'forward') {
              this.addConnection('message', sourceId, targetId, name);
            } else {
              this.addConnection('message', targetId, sourceId, name);
            }
            
            return targetId; // Return the "end" of the connection
          }
        }
        
        return null;
      }

      parseDataObject(line) {
        // Format: #Name task
        const parts = line.substring(1).trim().split(' ');
        const name = parts[0];
        const taskRef = parts.slice(1).join(' ');
        
        const dataObjId = `data_${this.normalizeId(name)}`;
        
        // Create data object even if there's no task reference
        this.dataObjects.push({
          type: 'dataObject',
          name: name,
          id: dataObjId,
          taskRef: taskRef // Store the raw reference
        });
        
        // If task reference can be resolved, create a connection
        const taskId = this.resolveTaskId(taskRef);
        if (taskId) {
          // Create a data association
          this.addConnection('data', dataObjId, taskId);
        }
        
        return dataObjId;
      }

      addConnection(type, sourceId, targetId, name = '') {
        const connId = `conn_${this.normalizeId(sourceId)}_${this.normalizeId(targetId)}`;
        
        this.connections.push({
          type: type === 'flow' ? 'sequenceFlow' : 
                type === 'message' ? 'messageFlow' : 'dataAssociation',
          id: connId,
          name: name,
          sourceRef: sourceId,
          targetRef: targetId
        });
      }

      connectSequentialTasks() {
        // Connect tasks in sequence within the same lane
        Object.values(this.lanes).forEach(lane => {
          let prevTask = null;
          
          for (let i = 0; i < lane.tasks.length; i++) {
            const currentTaskId = lane.tasks[i];
            const currentTask = this.tasks[currentTaskId];
            
            // Skip branches for normal flows (handled separately)
            if (currentTask.type === 'branch') {
              continue;
            }
            
            // For gateways, only connect from previous task to the gateway,
            // but don't create sequential flow from gateway to next task
            if (currentTask.type === 'gateway') {
              if (prevTask) {
                // Connect previous task to gateway
                const connectionExists = this.connections.some(conn => 
                  conn.type === 'sequenceFlow' && 
                  conn.sourceRef === prevTask && 
                  conn.targetRef === currentTaskId
                );
                
                if (!connectionExists) {
                  this.addConnection('flow', prevTask, currentTaskId);
                }
              }
              // Don't update prevTask for gateway
              continue;
            }
            
            // Connect the previous task to this one if both exist and not already connected
            if (prevTask) {
              // Check if connection already exists
              const connectionExists = this.connections.some(conn => 
                conn.type === 'sequenceFlow' && 
                conn.sourceRef === prevTask && 
                conn.targetRef === currentTaskId
              );
              
              if (!connectionExists) {
                this.addConnection('flow', prevTask, currentTaskId);
              }
            }
            
            // Update previous task for next iteration
            prevTask = currentTaskId;
          }
        });
        
        // Handle gateway branches specially
        Object.values(this.tasks).forEach(task => {
          // Handle only gateways with branches
          if (task.type !== 'gateway' || !task.branches || task.branches.length === 0) {
            return;
          }
          
          // Get positive and negative branches
          const positiveBranches = task.branches.filter(branchId => 
            this.tasks[branchId].branchType === 'positive'
          );
          
          const negativeBranches = task.branches.filter(branchId => 
            this.tasks[branchId].branchType === 'negative'
          );
          
          // Find the next task after this gateway in the lane
          const laneTaskIds = this.lanes[`@${task.lane}`].tasks;
          const gatewayIndex = laneTaskIds.indexOf(task.id);
          
          if (gatewayIndex !== -1) {
            // Connect all branches to their gateway first
            task.branches.forEach(branchId => {
              this.addConnection('flow', task.id, branchId);
            });
            
            // For positive branches, we need to find what to connect to
            if (positiveBranches.length > 0) {
              const positiveBranchId = positiveBranches[0];
              
              // Look for ship_order specifically (matching the expected example flow)
              const shipOrderTask = Object.values(this.tasks).find(t => 
                t.lane === task.lane && 
                t.name.toLowerCase().includes('ship order')
              );
              
              // Connect positive branch to ship_order if found
              if (shipOrderTask) {
                this.addConnection('flow', positiveBranchId, shipOrderTask.id);
              } else {
                // Otherwise, connect to the next task after gateway (fallback behavior)
                for (let i = gatewayIndex + 1; i < laneTaskIds.length; i++) {
                  const nextTaskId = laneTaskIds[i];
                  const nextTask = this.tasks[nextTaskId];
                  
                  // Skip branches of this gateway
                  if (nextTask.type === 'branch') {
                    continue;
                  }
                  
                  this.addConnection('flow', positiveBranchId, nextTaskId);
                  break;
                }
              }
            }
          }
        });
        
        // Connect matching send/receive tasks by message name
        const sendTasks = Object.values(this.tasks).filter(task => task.type === 'send');
        const receiveTasks = Object.values(this.tasks).filter(task => task.type === 'receive');
        
        sendTasks.forEach(sendTask => {
          // Use the message name property, not the full task name
          const messageName = sendTask.messageName;
          
          if (!messageName) return;
          
          // Find matching receive task with the same message name
          const matchingReceive = receiveTasks.find(receiveTask => 
            receiveTask.messageName === messageName
          );
          
          if (matchingReceive) {
            // Check if connection already exists
            const connectionExists = this.connections.some(conn => 
              conn.type === 'messageFlow' && 
              conn.sourceRef === sendTask.id && 
              conn.targetRef === matchingReceive.id
            );
            
            if (!connectionExists) {
              this.addConnection('message', sendTask.id, matchingReceive.id, messageName);
            }
          }
        });
      }

      resolveTaskId(taskRef) {
        if (!taskRef) return null;
        
        taskRef = taskRef.trim();
        
        // First try direct lookup
        if (this.taskScope[taskRef]) {
          return this.taskScope[taskRef];
        }
        
        // Try to normalize
        const normalized = this.normalizeId(taskRef);
        if (this.taskScope[normalized]) {
          return this.taskScope[normalized];
        }
        
        // Try different variations
        if (taskRef.includes('.')) {
          const parts = taskRef.split('.');
          
          if (parts.length === 2) {
            let [lane, task] = parts;
            if (lane.startsWith('@')) {
              lane = lane.substring(1);
            }
            
            // Try with and without @ prefix
            return this.taskScope[`${lane}.${this.normalizeId(task)}`] || 
                   this.taskScope[`@${lane}.${this.normalizeId(task)}`];
          }
        }
        
        return null;
      }

      normalizeId(name) {
        if (!name) return 'unknown';
        return name.toLowerCase()
          .replace(/[^a-z0-9]+/g, '_')
          .replace(/^_+|_+$/g, '');
      }

      toMermaid() {
        let mermaidCode = 'flowchart TD\n';
        
        // Define node styles first
        mermaidCode += '  %% Define node styles\n';
        mermaidCode += '  classDef rect fill:#bbf,stroke:#33f,stroke-width:2px\n';
        mermaidCode += '  classDef stadium fill:#bfb,stroke:#070,stroke-width:2px\n';
        mermaidCode += '  classDef diamond fill:#fcc,stroke:#f00,stroke-width:2px\n';
        mermaidCode += '  classDef note fill:#ffd,stroke:#bb0,stroke-width:1px\n\n';
        
        // Add data objects first
        this.dataObjects.forEach(dataObj => {
          mermaidCode += `  ${dataObj.id}[(${dataObj.name})]\n`;
        });
        
        // Add subgraphs for lanes
        Object.entries(this.lanes).forEach(([laneName, lane]) => {
          const laneId = this.normalizeId(laneName);
          mermaidCode += `  subgraph ${laneId}[${laneName.replace('@', '')}]\n`;
          
          // Add tasks in this lane (except branches)
          lane.tasks.forEach(taskId => {
            const task = this.tasks[taskId];
            
            // Skip branches - will render them as proper tasks
            if (task.type === 'branch') {
              const branchId = `${task.lane}_${this.normalizeId(task.name)}`;
              mermaidCode += `    ${branchId}["${task.name}"]:::rect\n`;
              return;
            }
            
            // Different shapes based on task type
            if (task.type === 'gateway') {
              mermaidCode += `    ${task.id}{${task.name}?}:::diamond\n`;
            } else if (task.type === 'comment') {
              mermaidCode += `    ${task.id}[/${task.name}/]:::note\n`;
            } else if (task.type === 'send' || task.type === 'receive') {
              mermaidCode += `    ${task.id}>${task.name}]:::stadium\n`;
            } else {
              // Default rectangular shape
              mermaidCode += `    ${task.id}[${task.name}]:::rect\n`;
            }
          });
          
          mermaidCode += '  end\n';
        });
        
        // Style subgraphs
        mermaidCode += '  style customer fill:#f9f9f9,stroke:#333,stroke-width:1px\n';
        mermaidCode += '  style system fill:#e6f3ff,stroke:#333,stroke-width:1px\n\n';
        
        // First collect all branches and their targets for gateway connections
        const branchConnections = {};
        Object.values(this.tasks).forEach(task => {
          if (task.type === 'branch') {
            const connections = this.connections.filter(conn => 
              conn.sourceRef === task.id && 
              conn.type === 'sequenceFlow'
            );
            
            if (connections.length > 0) {
              if (!branchConnections[task.parentGateway]) {
                branchConnections[task.parentGateway] = [];
              }
              
              connections.forEach(conn => {
                branchConnections[task.parentGateway].push({
                  branchType: task.branchType,
                  branchName: task.name,
                  targetId: conn.targetRef
                });
              });
            }
          }
        });
        
        // Collect normal flow connections
        const flowConnections = [];
        const messageFlows = [];
        const dataConnections = [];
        
        this.connections.forEach(conn => {
          const source = this.tasks[conn.sourceRef];
          const target = this.tasks[conn.targetRef];
          
          // Skip branch connections - handled separately
          if (source && source.type === 'branch') {
            return;
          }
          
          if (conn.type === 'sequenceFlow') {
            // Skip gateway connections - handled separately
            if (source && source.type === 'gateway') {
              return;
            }
            
            flowConnections.push(conn);
          } else if (conn.type === 'messageFlow') {
            messageFlows.push(conn);
          } else if (conn.type === 'dataAssociation') {
            dataConnections.push(conn);
          }
        });
        
        // Add all data connections
        dataConnections.forEach(conn => {
          mermaidCode += `  ${conn.sourceRef} -.-> ${conn.targetRef}\n`;
        });
        
        // Add all flow connections
        flowConnections.forEach(conn => {
          mermaidCode += `  ${conn.sourceRef} --> ${conn.targetRef}\n`;
        });
        
        // Add special gateway connections
        Object.entries(branchConnections).forEach(([gatewayId, connections]) => {
          // Sort connections by branch type (positive first)
          const sortedConnections = connections.sort((a, b) => 
            a.branchType === 'positive' ? -1 : 1
          );
          
          sortedConnections.forEach(conn => {
            const label = conn.branchType === 'positive' ? 'Yes' : 'No';
            mermaidCode += `  ${gatewayId} -->|${label}| ${this.tasks[conn.targetId] ? conn.targetId : `${this.tasks[gatewayId].lane}_${this.normalizeId(conn.branchName)}`}\n`;
          });
          
          // Connect positive branch to next task after gateway
          if (sortedConnections.length > 0) {
            const positiveConn = sortedConnections.find(c => c.branchType === 'positive');
            if (positiveConn) {
              // Find next task in lane after gateway
              const gateway = this.tasks[gatewayId];
              const laneTaskIds = this.lanes[`@${gateway.lane}`].tasks;
              const gatewayIndex = laneTaskIds.indexOf(gatewayId);
              
              if (gatewayIndex !== -1) {
                for (let i = gatewayIndex + 1; i < laneTaskIds.length; i++) {
                  const nextTaskId = laneTaskIds[i];
                  const nextTask = this.tasks[nextTaskId];
                  
                  // Skip branches
                  if (nextTask.type === 'branch') {
                    continue;
                  }
                  
                  // Don't need additional connection if it's already the target
                  const targetId = this.tasks[positiveConn.targetId] ? positiveConn.targetId : `${gateway.lane}_${this.normalizeId(positiveConn.branchName)}`;
                  
                  if (nextTaskId !== targetId) {
                    mermaidCode += `  ${gateway.lane}_${this.normalizeId(positiveConn.branchName)} --> ${nextTaskId}\n`;
                  }
                  
                  break;
                }
              }
            }
          }
        });
        
        // Add message flows
        messageFlows.forEach(conn => {
          mermaidCode += `  ${conn.sourceRef} -.->|${conn.name}| ${conn.targetRef}\n`;
        });
        
        return mermaidCode;
      }
    }
  </script>
</head>
<body>
  <header>
    <div class="title">BPMN-lite Parser Demo</div>
  </header>
  
  <div class="main-container">
    <div class="editor-container">
      <textarea id="code-editor" spellcheck="false"></textarea>
      <div class="editor-controls">
        <button id="parse-button">Parse DSL</button>
        <button id="render-button">Render Diagram</button>
      </div>
    </div>
    <div class="preview-container">
      <div class="preview-tabs">
        <div class="preview-tab active" data-tab="diagram">Diagram</div>
        <div class="preview-tab" data-tab="ast">AST</div>
        <div class="preview-tab" data-tab="mermaid">Mermaid Code</div>
      </div>
      <div id="error-container" class="error"></div>
      <div id="diagram-preview" class="preview-content active">
        <div id="mermaid-preview" class="mermaid-preview"></div>
      </div>
      <div id="ast-preview" class="preview-content ast-preview"></div>
      <div id="mermaid-code-preview" class="preview-content ast-preview"></div>
    </div>
  </div>
  
  <script>
    // No Mermaid initialization needed

    // Sample DSL
    const sampleDSL = `:Order Process

@Customer
  place order
  send: Payment Information
  "Customer waits for confirmation
  receive: Order Confirmation

@System
  receive: Payment Information
  process order
  validate payment
  ?Payment successful
    +post payment
    -stop order processing
  ship order
  send: Order Confirmation

^Order @Customer.place order -> @System.process order
#OrderData place order`;

    // Current state
    let currentAst = null;
    let currentMermaid = null;

    // DOM elements
    const codeEditor = document.getElementById('code-editor');
    const parseButton = document.getElementById('parse-button');
    const renderButton = document.getElementById('render-button');
    const mermaidPreview = document.getElementById('mermaid-preview');
    const astPreview = document.getElementById('ast-preview');
    const mermaidCodePreview = document.getElementById('mermaid-code-preview');
    const errorContainer = document.getElementById('error-container');
    const tabs = document.querySelectorAll('.preview-tab');
    const previewContents = document.querySelectorAll('.preview-content');
    
    // Set sample code
    codeEditor.value = sampleDSL;
    
    // Tab switching
    tabs.forEach(tab => {
      tab.addEventListener('click', () => {
        const tabName = tab.getAttribute('data-tab');
        
        // Update active tab
        tabs.forEach(t => t.classList.remove('active'));
        tab.classList.add('active');
        
        // Show/hide corresponding content
        previewContents.forEach(content => {
          content.classList.remove('active');
        });
        
        if (tabName === 'diagram') {
          document.getElementById('diagram-preview').classList.add('active');
        } else if (tabName === 'ast') {
          document.getElementById('ast-preview').classList.add('active');
        } else if (tabName === 'mermaid') {
          document.getElementById('mermaid-code-preview').classList.add('active');
        }
      });
    });
    
    // Parse button
    parseButton.addEventListener('click', () => {
      try {
        const parser = new BpmnLiteParser();
        currentAst = parser.parse(codeEditor.value);
        currentMermaid = parser.toMermaid();
        
        // Display AST
        astPreview.textContent = JSON.stringify(currentAst, null, 2);
        
        // Display Mermaid code
        mermaidCodePreview.textContent = currentMermaid;
        
        // Hide error
        errorContainer.style.display = 'none';
      } catch (error) {
        errorContainer.textContent = `Error parsing DSL: ${error.message || 'Unknown error'}`;
        errorContainer.style.display = 'block';
        
        console.error('Error parsing DSL:', error);
      }
    });
    
    // Render button
    renderButton.addEventListener('click', () => {
      // Parse first if needed
      if (!currentMermaid) {
        parseButton.click();
      }
      
      if (currentMermaid) {
        try {
          // Simply display the Mermaid code instead of rendering it
          mermaidPreview.innerHTML = '<pre class="mermaid-code">' + currentMermaid + '</pre>';
          
          // Add some styling for the code display
          const style = document.createElement('style');
          style.textContent = `
            .mermaid-code {
              font-family: monospace;
              white-space: pre-wrap;
              background-color: #f5f5f5;
              padding: 15px;
              border-radius: 5px;
              overflow: auto;
              width: 100%;
              height: 100%;
              box-sizing: border-box;
              margin: 0;
            }
          `;
          document.head.appendChild(style);
          
          // Hide error
          errorContainer.style.display = 'none';
        } catch (error) {
          errorContainer.textContent = `Error displaying Mermaid code: ${error.message || 'Unknown error'}`;
          errorContainer.style.display = 'block';
          
          console.error('Error displaying Mermaid code:', error);
        }
      }
    });
    
    // Initial parse and render
    parseButton.click();
    renderButton.click();
  </script>
</body>
</html>