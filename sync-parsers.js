// Sync parser from src/index.html to VSCode extension
// This script extracts the parser and converts it to TypeScript

const fs = require('fs');

console.log('Syncing parsers...\n');

// Read the HTML file
const html = fs.readFileSync('src/index.html', 'utf8');

// Extract the parser class
const parserMatch = html.match(/class BpmnLiteParser \{[\s\S]*?\n    \}/);
if (!parserMatch) {
  console.error('Could not find BpmnLiteParser in index.html');
  process.exit(1);
}

let parserCode = parserMatch[0];

// Convert to TypeScript
console.log('Converting to TypeScript...');

// Add type annotations
const typeReplacements = [
  // Properties
  [/this\.processes = \[\];/g, 'private processes: string[] = [];'],
  [/this\.lanes = \{\};/g, 'private lanes: Record<string, { process: string | null; tasks: string[] }> = {};'],
  [/this\.tasks = \{\};/g, 'private tasks: Record<string, any> = {};'],
  [/this\.connections = \[\];/g, 'private connections: any[] = [];'],
  [/this\.dataObjects = \[\];/g, 'private dataObjects: any[] = [];'],
  [/this\.messages = \[\];/g, 'private messages: any[] = [];'],
  [/this\.events = \[\];/g, 'private events: string[] = [];'],
  [/this\.currentProcess = null;/g, 'private currentProcess: string | null = null;'],
  [/this\.currentLane = null;/g, 'private currentLane: string | null = null;'],
  [/this\.lastTask = null;/g, 'private lastTask: string | null = null;'],
  [/this\.taskScope = \{\};/g, 'private taskScope: Record<string, string> = {};'],
  [/this\.gatewayStack = \[\];/g, 'private gatewayStack: string[] = [];'],
  [/this\.connectionBreaks = \[\];/g, 'private connectionBreaks: number[] = [];'],
  [/this\.taskLineNumbers = \{\};/g, 'private taskLineNumbers: Record<string, number> = {};'],
  [/this\.originalText = text;/g, 'private originalText: string = \'\';'],
  [/this\.currentLineIndex = 0;/g, 'private currentLineIndex: number = 0;'],
  
  // Method signatures
  [/parse\(text\) \{/g, 'parse(text: string): any {'],
  [/connectTasks\(\) \{/g, 'private connectTasks(): void {'],
  [/buildGlobalTaskOrder\(\) \{/g, 'private buildGlobalTaskOrder(): any[] {'],
  [/findTasksCreatedAtLine\(lineNumber\) \{/g, 'private findTasksCreatedAtLine(lineNumber: number): string[] {'],
  [/createImplicitConnections\(globalTaskOrder\) \{/g, 'private createImplicitConnections(globalTaskOrder: any[]): void {'],
  [/processExplicitArrowConnections\(\) \{/g, 'private processExplicitArrowConnections(): void {'],
  [/parseArrowConnections\(line, lineNumber\) \{/g, 'private parseArrowConnections(line: string, lineNumber: number): any[] {'],
  [/resolvePartToTaskId\(part, lineNumber\) \{/g, 'private resolvePartToTaskId(part: string, lineNumber: number): string | null {'],
  [/connectMessageFlows\(\) \{/g, 'private connectMessageFlows(): void {'],
  [/handleSpecialConnections\(globalTaskOrder\) \{/g, 'private handleSpecialConnections(globalTaskOrder: any[]): void {'],
  
  // Other methods
  [/(\w+)\(([^)]*)\) \{/g, (match, name, params) => {
    if (name === 'constructor') return match;
    if (match.includes('private')) return match;
    return `private ${name}(${params}): any {`;
  }]
];

// Move property declarations to class level
const constructorMatch = parserCode.match(/constructor\(\) \{[\s\S]*?\n      \}/);
if (constructorMatch) {
  const constructorBody = constructorMatch[0];
  const propertyDeclarations = [];
  
  // Extract property initializations
  const lines = constructorBody.split('\n');
  lines.forEach(line => {
    const match = line.match(/this\.(\w+) = (.+);/);
    if (match) {
      const [, name, value] = match;
      let type = 'any';
      if (value === '[]') type = 'any[]';
      else if (value === '{}') type = 'Record<string, any>';
      else if (value === 'null') type = 'string | null';
      else if (value === "''") type = 'string';
      else if (value === '0') type = 'number';
      
      propertyDeclarations.push(`    private ${name}: ${type} = ${value};`);
    }
  });
  
  // Replace constructor with empty one
  parserCode = parserCode.replace(constructorMatch[0], 'constructor() {\n      }');
  
  // Add property declarations before constructor
  const classDecl = 'class BpmnLiteParser {';
  parserCode = parserCode.replace(classDecl, classDecl + '\n' + propertyDeclarations.join('\n'));
}

// Apply type replacements
typeReplacements.forEach(([pattern, replacement]) => {
  parserCode = parserCode.replace(pattern, replacement);
});

// Add export and header
const tsCode = `// This is a TypeScript port of the BpmnLiteParser from the main application
// Auto-generated by sync-parsers.js - DO NOT EDIT DIRECTLY
// Last sync: ${new Date().toISOString()}

export ${parserCode}`;

// Write to TypeScript file
fs.writeFileSync('vscode-bpmn-lite/src/parser.ts', tsCode);
console.log('✅ Updated vscode-bpmn-lite/src/parser.ts');

// Compile TypeScript
console.log('\nCompiling TypeScript...');
const { execSync } = require('child_process');
try {
  execSync('cd vscode-bpmn-lite && npm run compile', { stdio: 'inherit' });
  console.log('✅ TypeScript compilation successful');
} catch (error) {
  console.error('❌ TypeScript compilation failed');
  console.error(error.message);
}