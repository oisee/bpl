<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>BPMN-Lite Parser Tests</title>
  <style>
    body {
      font-family: Arial, sans-serif;
      max-width: 800px;
      margin: 20px auto;
      padding: 20px;
    }
    .test-result {
      margin: 10px 0;
      padding: 10px;
      border-radius: 4px;
    }
    .test-pass {
      background-color: #d4edda;
      color: #155724;
      border: 1px solid #c3e6cb;
    }
    .test-fail {
      background-color: #f8d7da;
      color: #721c24;
      border: 1px solid #f5c6cb;
    }
    .test-summary {
      font-size: 1.2em;
      font-weight: bold;
      margin: 20px 0;
      padding: 15px;
      background-color: #f8f9fa;
      border-radius: 4px;
    }
    .test-error {
      margin-top: 5px;
      font-family: monospace;
      font-size: 0.9em;
    }
    button {
      padding: 10px 20px;
      font-size: 1em;
      background-color: #007bff;
      color: white;
      border: none;
      border-radius: 4px;
      cursor: pointer;
    }
    button:hover {
      background-color: #0056b3;
    }
  </style>
</head>
<body>
  <h1>BPMN-Lite Parser Test Suite</h1>
  <button onclick="runTests()">Run Tests</button>
  <div id="test-results"></div>
  
  <!-- Include the parser from the main application -->
  <script>
    // Copy the BpmnLiteParser class from src/index.html
    class BpmnLiteParser {
      constructor() {
        this.processes = [];
        this.lanes = {};
        this.tasks = {};
        this.connections = [];
        this.dataObjects = [];
        this.messages = [];
        this.events = [];
        this.currentProcess = null;
        this.currentLane = null;
        this.lastTask = null;
        this.taskScope = {};
        this.gatewayStack = [];
      }

      parse(text) {
        // Reset state
        this.processes = [];
        this.lanes = {};
        this.tasks = {};
        this.connections = [];
        this.dataObjects = [];
        this.messages = [];
        this.events = [];
        this.currentProcess = null;
        this.currentLane = null;
        this.lastTask = null;
        this.taskScope = {};
        this.gatewayStack = [];

        const lines = text.split('\n');
        
        // Create default process if none specified
        this.ensureProcess("Default Process");
        
        // First pass: collect processes, lanes, and tasks
        for (let i = 0; i < lines.length; i++) {
          const originalLine = lines[i];
          const line = originalLine.trim();
          if (!line) continue; // Skip empty lines
          
          // Find first non-whitespace character for line type detection
          const firstNonWhitespace = line.match(/\S/);
          if (!firstNonWhitespace) continue;
          
          const firstChar = firstNonWhitespace[0];
          
          // Check for connected parts with -> or <- operators
          const parts = this.splitConnections(line);
          
          if (parts.length > 1) {
            // Process each part and create the connections
            let prevTaskId = null;
            
            for (let j = 0; j < parts.length; j++) {
              const part = parts[j].trim();
              if (!part) continue;
              
              // Process this part
              const taskId = this.processLinePart(part, firstChar);
              
              // Create connection if we have a previous task
              if (prevTaskId && taskId) {
                const connectionType = parts[j-1].includes('<-') ? 'backward' : 'forward';
                
                if (connectionType === 'forward') {
                  this.addConnection('flow', prevTaskId, taskId);
                } else {
                  this.addConnection('flow', taskId, prevTaskId);
                }
              }
              
              if (taskId) {
                prevTaskId = taskId;
              }
            }
          } else {
            // Single part, process normally
            this.processLinePart(line, firstChar);
          }
        }

        // Automatically connect sequential tasks
        this.connectSequentialTasks();

        // Build the AST
        const ast = {
          type: 'bpmnModel',
          processes: this.processes.map(processName => ({
            type: 'process',
            name: processName,
            id: this.normalizeId(processName),
            lanes: Object.entries(this.lanes)
              .filter(([_, lane]) => lane.process === processName)
              .map(([laneName, lane]) => ({
                type: 'lane',
                name: laneName.replace('@', ''),
                id: this.normalizeId(laneName),
                elements: lane.tasks.map(taskId => this.tasks[taskId])
              }))
          })),
          connections: this.connections,
          dataObjects: this.dataObjects,
          messages: this.messages
        };

        return ast;
      }
      
      splitConnections(line) {
        // Split the line at -> and <- operators, preserving the operators
        const result = [];
        let currentPart = '';
        let i = 0;
        
        while (i < line.length) {
          if (line.substr(i, 2) === '->' || line.substr(i, 2) === '<-') {
            result.push(currentPart);
            result.push(line.substr(i, 2));
            currentPart = '';
            i += 2;
          } else {
            currentPart += line[i];
            i++;
          }
        }
        
        if (currentPart) {
          result.push(currentPart);
        }
        
        // Rejoin into proper parts that maintain the operator with the right part
        const parts = [];
        for (let i = 0; i < result.length; i++) {
          if (result[i] === '->' || result[i] === '<-') {
            parts[parts.length - 1] += result[i];
          } else {
            parts.push(result[i]);
          }
        }
        
        return parts;
      }
      
      processLinePart(line, firstChar) {
        // Process based on the first character
        let taskId = null;
        
        switch(firstChar) {
          case ':': // Process definition
            this.parseProcess(line);
            break;
          case '@': // Lane definition
            this.parseLane(line);
            break;
          case '^': // Message flow
            taskId = this.parseConnection(line);
            break;
          case '#': // Data object
            taskId = this.parseDataObject(line);
            break;
          case '?': // Gateway
            taskId = this.parseGateway(line);
            break;
          case '+': // Positive branch
          case '-': // Negative branch
            taskId = this.parseGatewayBranch(line, firstChar);
            break;
          case '"': // Comment
            taskId = this.parseComment(line);
            break;
          case '!': // Event
            taskId = this.parseEvent(line);
            break;
          case '/': // Technical comment (ignored)
            if (line.startsWith('//')) {
              // Ignore technical comments
              break;
            }
            // If not a comment, treat as a task
            taskId = this.parseTask(line);
            break;
          default:
            // Check if this is a task
            taskId = this.parseTask(line);
        }
        
        // Update last task if we created one
        if (taskId) {
          this.lastTask = taskId;
        }
        
        return taskId;
      }
      
      parseEvent(line) {
        if (!this.currentLane) {
          // Create a default lane if needed
          this.parseLane('@Default');
        }
        
        const eventName = line.substring(1).trim(); // Remove the ! prefix
        const laneName = this.currentLane.replace('@', '');
        let eventType = 'intermediate';
        
        // Determine event type based on common keywords
        if (eventName.toLowerCase() === 'start') {
          eventType = 'start';
        } else if (eventName.toLowerCase() === 'end') {
          eventType = 'end';
        }
        
        const eventId = `${laneName}_${eventType}`;
        
        this.tasks[eventId] = {
          type: 'event',
          eventType: eventType,
          name: eventName,
          id: eventId,
          lane: laneName
        };
        
        this.lanes[this.currentLane].tasks.push(eventId);
        
        // Add event to scope for reference
        const simpleName = this.normalizeId(eventName);
        this.taskScope[simpleName] = eventId;
        this.taskScope[`${laneName}.${simpleName}`] = eventId;
        this.taskScope[`@${laneName}.${simpleName}`] = eventId;
        
        // Track event for special handling
        this.events.push(eventId);
        
        return eventId;
      }

      ensureProcess(name) {
        if (!this.processes.includes(name)) {
          this.processes.push(name);
          this.currentProcess = name;
        }
      }

      parseProcess(line) {
        const processName = line.substring(1).trim();
        this.ensureProcess(processName);
      }

      parseLane(line) {
        const laneName = line.trim();
        if (!this.lanes[laneName]) {
          this.lanes[laneName] = {
            process: this.currentProcess,
            tasks: []
          };
        }
        this.currentLane = laneName;
        this.lastTask = null; // Reset last task when changing lanes
      }

      parseTask(line) {
        if (!this.currentLane) {
          // Create a default lane if needed
          this.parseLane('@Default');
        }
        
        // Already trimmed the line in the main parse method
        if (!line) return null;
        
        let taskType = 'task';
        let taskName = line;
        let originalName = line; // Keep the original name for display
        
        // Check task type based on prefix
        if (line.startsWith('send:')) {
          taskType = 'send';
          taskName = line.substring(5).trim(); // Extract just the message name
          originalName = `send: ${taskName}`; // Keep the "send:" prefix in display name
        } else if (line.startsWith('receive:')) {
          taskType = 'receive';
          taskName = line.substring(8).trim(); // Extract just the message name
          originalName = `receive: ${taskName}`; // Keep the "receive:" prefix in display name
        }
        
        const laneName = this.currentLane.replace('@', '');
        const taskId = `${laneName}_${this.normalizeId(originalName)}`;
        
        this.tasks[taskId] = {
          type: taskType,
          name: originalName, // Use original name with prefix for display
          messageName: taskType === 'send' || taskType === 'receive' ? taskName : null, // Store message name separately
          id: taskId,
          lane: laneName
        };
        
        this.lanes[this.currentLane].tasks.push(taskId);
        
        // Add task to scope for reference in connections
        // Use simplified name without prefixes for lookup
        const simpleName = this.normalizeId(taskName);
        this.taskScope[simpleName] = taskId;
        this.taskScope[`${laneName}.${simpleName}`] = taskId;
        this.taskScope[`@${laneName}.${simpleName}`] = taskId;
        
        // Also add the full name with prefix for reference
        const fullName = this.normalizeId(originalName);
        this.taskScope[fullName] = taskId;
        this.taskScope[`${laneName}.${fullName}`] = taskId;
        this.taskScope[`@${laneName}.${fullName}`] = taskId;
        
        return taskId;
      }

      parseGateway(line) {
        if (!this.currentLane) {
          // Create a default lane if needed
          this.parseLane('@Default');
        }
        
        const gatewayName = line.substring(1).trim();
        const laneName = this.currentLane.replace('@', '');
        const gatewayId = `${laneName}_${this.normalizeId(gatewayName)}`;
        
        this.tasks[gatewayId] = {
          type: 'gateway',
          gatewayType: 'exclusive',
          name: gatewayName,
          id: gatewayId,
          lane: laneName,
          branches: []
        };
        
        this.lanes[this.currentLane].tasks.push(gatewayId);
        
        // Add gateway to scope for reference
        const simpleName = this.normalizeId(gatewayName);
        this.taskScope[simpleName] = gatewayId;
        this.taskScope[`${laneName}.${simpleName}`] = gatewayId;
        this.taskScope[`@${laneName}.${simpleName}`] = gatewayId;
        
        // Push to gateway stack
        this.gatewayStack.push(gatewayId);
        
        return gatewayId;
      }

      parseGatewayBranch(line, branchChar) {
        if (this.gatewayStack.length === 0) {
          // No gateway to attach to
          return null;
        }
        
        const parentGateway = this.gatewayStack[this.gatewayStack.length - 1];
        const branchName = line.substring(1).trim();
        const laneName = this.currentLane.replace('@', '');
        const branchId = `${laneName}_${this.normalizeId(branchName)}`;
        
        // Check if this is a special format branch with custom label
        let displayName = branchName;
        let branchLabel = branchChar === '+' ? 'Yes' : 'No';
        
        // Check for custom label format |Label|content
        if (branchName.startsWith('|') && branchName.includes('|', 1)) {
          const labelEnd = branchName.indexOf('|', 1);
          branchLabel = branchName.substring(1, labelEnd);
          displayName = branchName.substring(labelEnd + 1).trim();
        }
        
        this.tasks[branchId] = {
          type: 'branch',
          branchType: branchChar === '+' ? 'positive' : 'negative',
          name: displayName,
          label: branchLabel,
          id: branchId,
          lane: laneName,
          parentGateway: parentGateway
        };
        
        // Add branch to parent gateway
        this.tasks[parentGateway].branches.push(branchId);
        
        // Add to lane
        this.lanes[this.currentLane].tasks.push(branchId);
        
        // Add branch to scope for reference
        const simpleName = this.normalizeId(displayName);
        this.taskScope[simpleName] = branchId;
        this.taskScope[`${laneName}.${simpleName}`] = branchId;
        this.taskScope[`@${laneName}.${simpleName}`] = branchId;
        
        // Note: Connections will be added in connectSequentialTasks() to avoid duplicates
        
        return branchId;
      }

      parseComment(line) {
        if (!this.currentLane) {
          // Create a default lane if needed
          this.parseLane('@Default');
        }
        
        const commentText = line.substring(1).trim();
        const laneName = this.currentLane.replace('@', '');
        const commentId = `${laneName}_comment_${this.normalizeId(commentText.substring(0, 20))}`;
        
        this.tasks[commentId] = {
          type: 'comment',
          name: commentText,
          id: commentId,
          lane: laneName
        };
        
        this.lanes[this.currentLane].tasks.push(commentId);
        
        return commentId;
      }

      parseConnection(line) {
        // Format: ^MessageName @Source.task -> @Target.task
        if (line.startsWith('^')) {
          try {
            console.log(`Processing message flow: ${line}`);
            
            // Extract the entire line content after the ^ prefix
            const content = line.substring(1).trim();
            
            // First check for arrow
            let sourcePart, targetPart, messageName, direction;
            
            if (content.includes('->')) {
              [sourcePart, targetPart] = content.split('->').map(s => s.trim());
              direction = 'forward';
            } else if (content.includes('<-')) {
              [targetPart, sourcePart] = content.split('<-').map(s => s.trim());
              direction = 'backward';
            } else {
              // No arrow, assume it's just a message name (old format)
              messageName = content;
              // This is handled differently, return early
              console.log(`Simple message name: ${messageName}`);
              return null;
            }
            
            // Process the source part - first word is the message name if it doesn't contain '@'
            if (sourcePart.includes('@')) {
              // Format is: MessageName @Source.task
              const parts = sourcePart.split(' ');
              messageName = parts[0];
              const sourceRef = parts.slice(1).join(' ');
              console.log(`Complex format - Message: "${messageName}", Source: "${sourceRef}", Target: "${targetPart}"`);
              
              // Resolve source and target
              const sourceId = this.resolveTaskId(sourceRef);
              const targetId = this.resolveTaskId(targetPart);
              
              if (sourceId && targetId) {
                // Create the message object
                const messageId = `message_${this.normalizeId(messageName)}`;
                
                // Add to messages array if not already there
                if (!this.messages.find(m => m.id === messageId)) {
                  this.messages.push({
                    type: 'message',
                    name: messageName,
                    id: messageId,
                    sourceRef: sourceId,
                    targetRef: targetId
                  });
                  console.log(`Added message: ${messageName} (${messageId})`);
                }
                
                // Create connection in the right direction
                this.addConnection('message', sourceId, targetId, messageName);
                console.log(`SUCCESSFULLY added message flow: "${messageName}" from ${sourceId} to ${targetId}`);
                
                return targetId; // Return the target as the last referenced task
              } else {
                console.error(`Failed to resolve IDs: source="${sourceRef}" (${sourceId || 'null'}), target="${targetPart}" (${targetId || 'null'})`);
              }
            } else {
              // Simple format - source and target are directly provided
              messageName = sourcePart;
              console.log(`Simple format - Message: "${messageName}", Target: "${targetPart}"`);
              
              // Try to find a source (probably the last task)
              const sourceId = this.lastTask;
              const targetId = this.resolveTaskId(targetPart);
              
              if (sourceId && targetId) {
                // Create the message object
                const messageId = `message_${this.normalizeId(messageName)}`;
                
                // Add to messages array if not already there
                if (!this.messages.find(m => m.id === messageId)) {
                  this.messages.push({
                    type: 'message',
                    name: messageName,
                    id: messageId,
                    sourceRef: sourceId,
                    targetRef: targetId
                  });
                  console.log(`Added message: ${messageName} (${messageId})`);
                }
                
                this.addConnection('message', sourceId, targetId, messageName);
                console.log(`SUCCESSFULLY added simple message flow: "${messageName}" from ${sourceId} to ${targetId}`);
                return targetId;
              }
            }
          } catch (error) {
            console.error(`Error parsing message flow: ${line}`, error);
          }
        }
        
        return null;
      }

      parseDataObject(line) {
        // Format: #Name task_reference
        try {
          const content = line.substring(1).trim();
          const parts = content.split(' ');
          const name = parts[0];
          const taskRef = parts.slice(1).join(' ');
          
          console.log(`Parsing data object: "${name}", task reference="${taskRef}"`);
          
          const dataObjId = `data_${this.normalizeId(name)}`;
          
          // Create data object even if there's no task reference
          this.dataObjects.push({
            type: 'dataObject',
            name: name,
            id: dataObjId,
            taskRef: taskRef // Store the raw reference
          });
          
          // If task reference can be resolved, create a connection
          if (taskRef) {
            const taskId = this.resolveTaskId(taskRef);
            if (taskId) {
              // Create a data association
              this.addConnection('data', dataObjId, taskId);
              console.log(`Added data association from ${dataObjId} to ${taskId}`);
            } else {
              console.log(`Failed to resolve task ID for data object association: "${taskRef}"`);
            }
          }
          
          return dataObjId;
        } catch (error) {
          console.error(`Error parsing data object: ${line}`, error);
          return null;
        }
      }

      addConnection(type, sourceId, targetId, name = '') {
        const connId = `conn_${this.normalizeId(sourceId)}_${this.normalizeId(targetId)}`;
        
        this.connections.push({
          type: type === 'flow' ? 'sequenceFlow' : 
                type === 'message' ? 'messageFlow' : 'dataAssociation',
          id: connId,
          name: name,
          sourceRef: sourceId,
          targetRef: targetId
        });
      }

      connectSequentialTasks() {
        // First build a map of tasks and their sequence
        const gatewayMap = {};
        const gatewayBranchesMap = {};
        
        // Find all gateways and their branches
        Object.values(this.tasks).forEach(task => {
          if (task.type === 'gateway') {
            gatewayMap[task.id] = task;
            gatewayBranchesMap[task.id] = {
              positive: [],
              negative: [],
              nextTask: null
            };
          }
        });
        
        // Collect branches for each gateway
        Object.values(this.tasks).forEach(task => {
          if (task.type === 'branch' && task.parentGateway && gatewayBranchesMap[task.parentGateway]) {
            if (task.branchType === 'positive') {
              gatewayBranchesMap[task.parentGateway].positive.push(task.id);
            } else {
              gatewayBranchesMap[task.parentGateway].negative.push(task.id);
            }
          }
        });
        
        // Connect tasks in sequence within the same lane
        Object.values(this.lanes).forEach(lane => {
          let prevTask = null;
          
          // First find any gateway blocks in this lane
          const gateways = lane.tasks.filter(taskId => 
            this.tasks[taskId] && this.tasks[taskId].type === 'gateway'
          );
          
          // For each gateway, find the next task after it and its branches
          gateways.forEach(gatewayId => {
            const gateway = this.tasks[gatewayId];
            const gatewayIndex = lane.tasks.indexOf(gatewayId);
            
            // Find the first non-branch task after the gateway
            for (let i = gatewayIndex + 1; i < lane.tasks.length; i++) {
              const taskId = lane.tasks[i];
              const task = this.tasks[taskId];
              
              // Skip branches belonging to this gateway
              if (task.type === 'branch' && task.parentGateway === gatewayId) {
                continue;
              }
              
              // Skip other gateways
              if (task.type === 'gateway') {
                continue;
              }
              
              // Found the next task, store it
              gatewayBranchesMap[gatewayId].nextTask = taskId;
              break;
            }
          });
          
          // Now do sequential connections, skipping gateways
          for (let i = 0; i < lane.tasks.length; i++) {
            const currentTaskId = lane.tasks[i];
            const currentTask = this.tasks[currentTaskId];
            
            // Skip branches
            if (currentTask.type === 'branch') {
              continue;
            }
            
            // For gateways, only connect from previous task to the gateway
            if (currentTask.type === 'gateway') {
              if (prevTask) {
                // Connect previous task to gateway
                this.addConnection('flow', prevTask, currentTaskId);
              }
              
              // Don't update prevTask for gateway
              continue;
            }
            
            // Check if this is a task right after a gateway
            let isAfterGateway = false;
            let sourceGateway = null;
            
            for (const [gId, data] of Object.entries(gatewayBranchesMap)) {
              if (data.nextTask === currentTaskId) {
                isAfterGateway = true;
                sourceGateway = gId;
                break;
              }
            }
            
            // If this is a task right after a gateway and has a previous task
            // that's not the gateway, we might need to skip the connection
            if (isAfterGateway && prevTask && !gatewayMap[prevTask]) {
              // Don't connect if it's already connected from the gateway
              const fromGatewayConnections = this.connections.filter(conn =>
                conn.sourceRef === sourceGateway && conn.targetRef === currentTaskId
              );
              
              if (fromGatewayConnections.length > 0) {
                // Skip this connection, it comes from the gateway
                prevTask = currentTaskId;
                continue;
              }
            }
            
            // Connect the previous task to this one if it exists
            if (prevTask) {
              // Check if connection already exists
              const connectionExists = this.connections.some(conn => 
                conn.type === 'sequenceFlow' && 
                conn.sourceRef === prevTask && 
                conn.targetRef === currentTaskId
              );
              
              if (!connectionExists) {
                this.addConnection('flow', prevTask, currentTaskId);
              }
            }
            
            // Update previous task for next iteration
            prevTask = currentTaskId;
          }
        });
        
        // Now handle branches and gateway connections
        Object.entries(gatewayBranchesMap).forEach(([gatewayId, data]) => {
          const gateway = this.tasks[gatewayId];
          
          // Connect gateway to all branches
          gateway.branches.forEach(branchId => {
            this.addConnection('flow', gatewayId, branchId);
          });
          
          // Handle positive branches - connect to specific targets
          data.positive.forEach(branchId => {
            const branch = this.tasks[branchId];
            
            // Connect to the ship_order task if this is the payment gateway
            // This is a special case just for the demo example
            if (gateway.name.toLowerCase().includes('payment')) {
              const shipOrderTask = Object.values(this.tasks).find(task => 
                task.lane === gateway.lane && 
                task.name.toLowerCase().includes('ship order')
              );
              
              if (shipOrderTask) {
                this.addConnection('flow', branchId, shipOrderTask.id);
              } else if (data.nextTask) {
                // Connect to the task after the gateway
                this.addConnection('flow', branchId, data.nextTask);
              }
            } else if (data.nextTask) {
              // Connect to the task after the gateway
              this.addConnection('flow', branchId, data.nextTask);
            }
          });
          
          // Don't automatically connect negative branches to anything
          // They're dead ends unless explicitly connected
        });
        
        // Connect matching send/receive tasks by message name
        const sendTasks = Object.values(this.tasks).filter(task => task.type === 'send');
        const receiveTasks = Object.values(this.tasks).filter(task => task.type === 'receive');
        
        sendTasks.forEach(sendTask => {
          // Use the message name property, not the full task name
          const messageName = sendTask.messageName;
          
          if (!messageName) return;
          
          // Find matching receive task with the same message name
          const matchingReceive = receiveTasks.find(receiveTask => 
            receiveTask.messageName === messageName
          );
          
          if (matchingReceive) {
            // Check if connection already exists
            const connectionExists = this.connections.some(conn => 
              conn.type === 'messageFlow' && 
              conn.sourceRef === sendTask.id && 
              conn.targetRef === matchingReceive.id
            );
            
            if (!connectionExists) {
              // Create the message object
              const messageId = `message_${this.normalizeId(messageName)}`;
              
              // Add to messages array if not already there
              if (!this.messages.find(m => m.id === messageId)) {
                this.messages.push({
                  type: 'message',
                  name: messageName,
                  id: messageId,
                  sourceRef: sendTask.id,
                  targetRef: matchingReceive.id
                });
                console.log(`Added implicit message: ${messageName} (${messageId})`);
              }
              
              this.addConnection('message', sendTask.id, matchingReceive.id, messageName);
            }
          }
        });
        
        // Connect across lanes for tasks that should follow each other
        this.connectAcrossLanes();
        
        // Special handling for start/end events
        this.connectEvents();
      }
      
      connectAcrossLanes() {
        // Get all tasks sorted by their position in the process
        const allLanes = Object.values(this.lanes);
        const allTasksByPosition = [];
        
        // Flatten all tasks, maintaining their order from the lanes
        allLanes.forEach(lane => {
          lane.tasks.forEach(taskId => {
            const task = this.tasks[taskId];
            if (task && task.type !== 'branch') {
              allTasksByPosition.push(task.id);
            }
          });
        });
        
        // Add tasks not explicitly in lanes (if any)
        Object.values(this.tasks).forEach(task => {
          if (!allTasksByPosition.includes(task.id) && task.type !== 'branch') {
            allTasksByPosition.push(task.id);
          }
        });
        
        // Last task of the previous lane should connect to the first task of the next lane
        for (let i = 0; i < allLanes.length - 1; i++) {
          const currentLane = allLanes[i];
          const nextLane = allLanes[i + 1];
          
          // Skip if either lane is empty
          if (currentLane.tasks.length === 0 || nextLane.tasks.length === 0) {
            continue;
          }
          
          // Find the last non-branch task in the current lane
          let lastTaskInCurrentLane = null;
          for (let j = currentLane.tasks.length - 1; j >= 0; j--) {
            const taskId = currentLane.tasks[j];
            const task = this.tasks[taskId];
            if (task && task.type !== 'branch') {
              lastTaskInCurrentLane = taskId;
              break;
            }
          }
          
          // Find the first non-branch task in the next lane
          let firstTaskInNextLane = null;
          for (let j = 0; j < nextLane.tasks.length; j++) {
            const taskId = nextLane.tasks[j];
            const task = this.tasks[taskId];
            if (task && task.type !== 'branch') {
              firstTaskInNextLane = taskId;
              break;
            }
          }
          
          // Connect them if both found
          if (lastTaskInCurrentLane && firstTaskInNextLane) {
            // Check if connection already exists
            const connectionExists = this.connections.some(conn => 
              conn.type === 'sequenceFlow' && 
              conn.sourceRef === lastTaskInCurrentLane && 
              conn.targetRef === firstTaskInNextLane
            );
            
            // Also check if the target task is already connected to from something else
            const targetAlreadyConnected = this.connections.some(conn =>
              conn.type === 'sequenceFlow' &&
              conn.targetRef === firstTaskInNextLane
            );
            
            // Only add if no connection exists and target isn't already connected
            if (!connectionExists && !targetAlreadyConnected) {
              this.addConnection('flow', lastTaskInCurrentLane, firstTaskInNextLane);
            }
          }
        }
      }
      
      connectEvents() {
        // Process each lane to connect start/end events properly
        Object.values(this.lanes).forEach(lane => {
          // Find start events
          const startEvents = lane.tasks.filter(taskId => {
            const task = this.tasks[taskId];
            return task && task.type === 'event' && task.eventType === 'start';
          });
          
          // Find end events
          const endEvents = lane.tasks.filter(taskId => {
            const task = this.tasks[taskId];
            return task && task.type === 'event' && task.eventType === 'end';
          });
          
          // Connect start events to first non-event task
          startEvents.forEach(startEventId => {
            // Find the first regular task after the start event
            let firstTaskAfterStart = null;
            let startEventIndex = lane.tasks.indexOf(startEventId);
            
            for (let i = startEventIndex + 1; i < lane.tasks.length; i++) {
              const taskId = lane.tasks[i];
              const task = this.tasks[taskId];
              
              // Skip other events
              if (task && task.type !== 'event' && task.type !== 'branch') {
                firstTaskAfterStart = taskId;
                break;
              }
            }
            
            // If found, connect them
            if (firstTaskAfterStart) {
              // Check if connection already exists
              const connectionExists = this.connections.some(conn => 
                conn.type === 'sequenceFlow' && 
                conn.sourceRef === startEventId && 
                conn.targetRef === firstTaskAfterStart
              );
              
              if (!connectionExists) {
                this.addConnection('flow', startEventId, firstTaskAfterStart);
              }
            }
          });
          
          // Connect last non-event task to end events
          endEvents.forEach(endEventId => {
            // Find the last regular task before the end event
            let lastTaskBeforeEnd = null;
            let endEventIndex = lane.tasks.indexOf(endEventId);
            
            for (let i = endEventIndex - 1; i >= 0; i--) {
              const taskId = lane.tasks[i];
              const task = this.tasks[taskId];
              
              // Skip other events
              if (task && task.type !== 'event' && task.type !== 'branch') {
                lastTaskBeforeEnd = taskId;
                break;
              }
            }
            
            // If found, connect them
            if (lastTaskBeforeEnd) {
              // Check if connection already exists
              const connectionExists = this.connections.some(conn => 
                conn.type === 'sequenceFlow' && 
                conn.sourceRef === lastTaskBeforeEnd && 
                conn.targetRef === endEventId
              );
              
              if (!connectionExists) {
                this.addConnection('flow', lastTaskBeforeEnd, endEventId);
              }
            }
          });
        });
      }

      resolveTaskId(taskRef) {
        if (!taskRef) return null;
        
        taskRef = taskRef.trim();
        console.log(`Resolving task ID for: "${taskRef}"`);
        
        // First try direct lookup
        if (this.taskScope[taskRef]) {
          console.log(`  Direct lookup success: ${this.taskScope[taskRef]}`);
          return this.taskScope[taskRef];
        }
        
        // Try to normalize
        const normalized = this.normalizeId(taskRef);
        if (this.taskScope[normalized]) {
          console.log(`  Normalized lookup success: ${this.taskScope[normalized]}`);
          return this.taskScope[normalized];
        }
        
        // If the reference includes a lane (has '@Lane.task' format)
        if (taskRef.includes('.')) {
          const parts = taskRef.split('.');
          
          if (parts.length === 2) {
            let [lane, task] = parts;
            
            // Remove @ prefix if present
            if (lane.startsWith('@')) {
              lane = lane.substring(1);
            }
            
            // Normalize task name
            const normalizedTask = this.normalizeId(task);
            
            // Try various combinations
            const lookups = [
              `${lane}.${normalizedTask}`,
              `@${lane}.${normalizedTask}`,
              `${lane}_${normalizedTask}`
            ];
            
            // Also try with lane name variations (lowercase, normalized)
            const normalizedLane = this.normalizeId(lane);
            lookups.push(
              `${normalizedLane}.${normalizedTask}`,
              `@${normalizedLane}.${normalizedTask}`,
              `${normalizedLane}_${normalizedTask}`
            );
            
            // Try each lookup
            for (const lookup of lookups) {
              if (this.taskScope[lookup]) {
                console.log(`  Complex lookup success: ${this.taskScope[lookup]} (via ${lookup})`);
                return this.taskScope[lookup];
              }
            }
            
            // Try direct lookup of the combined ID format (lane_task)
            const directId = `${lane}_${normalizedTask}`;
            if (this.tasks[directId]) {
              console.log(`  Direct ID lookup success: ${directId}`);
              return directId;
            }
            
            // Try all tasks to find a matching name in the given lane
            const laneTasks = Object.values(this.tasks).filter(t => 
              t.lane && t.lane.toLowerCase() === lane.toLowerCase()
            );
            
            // Find a task with a matching name in this lane
            const matchingTask = laneTasks.find(t => 
              this.normalizeId(t.name) === normalizedTask || 
              (t.messageName && this.normalizeId(t.messageName) === normalizedTask)
            );
            
            if (matchingTask) {
              console.log(`  Lane tasks search success: ${matchingTask.id}`);
              return matchingTask.id;
            }
          }
        } else {
          // If no lane specified, search all tasks for a name match
          const matchingTask = Object.values(this.tasks).find(t => 
            this.normalizeId(t.name) === normalized || 
            (t.messageName && this.normalizeId(t.messageName) === normalized)
          );
          
          if (matchingTask) {
            console.log(`  Global name search success: ${matchingTask.id}`);
            return matchingTask.id;
          }
        }
        
        console.log(`  Resolution failed for: "${taskRef}"`);
        return null;
      }

      normalizeId(name) {
        if (!name) return 'unknown';
        return name.toLowerCase()
          .replace(/[^a-z0-9]+/g, '_')
          .replace(/^_+|_+$/g, '');
      }

      toMermaid() {
        // Start with flowchart definition and style classes
        let mermaid = `flowchart TD
  %% Define node styles
  classDef event fill:#ffd,stroke:#33f,stroke-width:2px
  classDef task fill:#bbf,stroke:#33f,stroke-width:2px
  classDef message fill:#bfb,stroke:#070,stroke-width:2px
  classDef gateway fill:#fcc,stroke:#f00,stroke-width:2px
  classDef comment fill:#ffd,stroke:#bb0,stroke-width:1px
  classDef dataObject fill:#ececff,stroke:#9370db,stroke-width:1px
  classDef branch fill:#d5ffd5,stroke:#3cb371,stroke-width:1px
`;

        // Add data objects
        this.dataObjects.forEach(dataObj => {
          mermaid += `  ${dataObj.id}[(${dataObj.name})]:::dataObject\n`;
        });

        // Group by lanes/pools
        const laneNodes = {};
        
        // Collect nodes for each lane (including branches)
        Object.entries(this.lanes).forEach(([laneName, lane]) => {
          const normalizedLaneName = this.normalizeId(laneName.replace('@', ''));
          laneNodes[normalizedLaneName] = lane.tasks.filter(taskId => {
            const task = this.tasks[taskId];
            return task; // Include all task types in subgraphs
          });
        });
        
        // Add subgraphs for each lane
        Object.entries(laneNodes).forEach(([laneName, taskIds]) => {
          if (taskIds.length > 0) {
            mermaid += `  subgraph ${laneName}[${laneName}]\n`;
            
            // Add nodes for each task in the lane
            taskIds.forEach(taskId => {
              const task = this.tasks[taskId];
              
              if (!task) return;
              
              switch(task.type) {
                case 'task':
                  mermaid += `    ${task.id}[${task.name}]:::task\n`;
                  break;
                case 'send':
                case 'receive':
                  mermaid += `    ${task.id}>${task.name}]:::message\n`;
                  break;
                case 'gateway':
                  mermaid += `    ${task.id}{${task.name}?}:::gateway\n`;
                  break;
                case 'branch':
                  mermaid += `    ${task.id}["${task.name}"]:::branch\n`;
                  break;
                case 'comment':
                  mermaid += `    ${task.id}[/${task.name}/]:::comment\n`;
                  break;
                case 'event':
                  mermaid += `    ${task.id}([${task.name}]):::event\n`;
                  break;
              }
            });
            
            mermaid += `  end\n`;
          }
        });
        
        // Add branch nodes inside their parent lane subgraphs
        // This is handled in the lane subgraph code already
        
        // Add lane styles
        Object.keys(laneNodes).forEach((laneName, index) => {
          const color = index % 2 === 0 ? 
            'fill:#f9f9f9,stroke:#333,stroke-width:1px' : 
            'fill:#e6f3ff,stroke:#333,stroke-width:1px';
          mermaid += `  style ${laneName} ${color}\n`;
        });
        
        // Add connections
        mermaid += '\n';
        
        // Add normal sequence flows
        mermaid += '  %% Sequence flows\n';
        this.connections.forEach(conn => {
          if (conn.type === 'sequenceFlow') {
            // Check if this is a gateway-to-branch connection
            const source = this.tasks[conn.sourceRef];
            const target = this.tasks[conn.targetRef];
            
            if (source && target) {
              if (source.type === 'gateway' && target.type === 'branch') {
                // Special formatting for gateway branches with labels
                mermaid += `  ${conn.sourceRef} -->|${target.label}| ${conn.targetRef}\n`;
              } else {
                mermaid += `  ${conn.sourceRef} --> ${conn.targetRef}\n`;
              }
            }
          }
        });
        
        // Add message flows with dashed lines and labels
        mermaid += '  %% Message flows\n';
        this.connections.forEach(conn => {
          if (conn.type === 'messageFlow') {
            const label = conn.name ? `|${conn.name}|` : '';
            mermaid += `  ${conn.sourceRef} -.->${ label } ${conn.targetRef}\n`;
          }
        });
        
        // Add data associations with dashed lines
        mermaid += '  %% Data flows\n';
        this.connections.forEach(conn => {
          if (conn.type === 'dataAssociation') {
            mermaid += `  ${conn.sourceRef} -.-> ${conn.targetRef}\n`;
          }
        });
        
        return mermaid;
      }
    }
  </script>
  
  <script>
    // Test framework
    let results = [];
    
    function assert(condition, message) {
      if (!condition) {
        throw new Error(message || 'Assertion failed');
      }
    }
    
    function test(name, fn) {
      try {
        fn();
        results.push({ name, passed: true });
      } catch (error) {
        results.push({ name, passed: false, error: error.message });
      }
    }
    
    function runTests() {
      results = [];
      
      // Test 1: Basic Process Parsing
      test('Should parse basic process definition', () => {
        const parser = new BpmnLiteParser();
        const dsl = ':Order Process';
        const ast = parser.parse(dsl);
        
        assert(ast.type === 'bpmnModel');
        assert(ast.processes.length === 1);
        assert(ast.processes[0].name === 'Order Process');
      });
      
      // Test 2: Lane and Task Parsing
      test('Should parse lanes and tasks', () => {
        const parser = new BpmnLiteParser();
        const dsl = `
:Order Process
@Customer
  place order
  make payment
@System
  process order
  ship item
`;
        const ast = parser.parse(dsl);
        
        assert(ast.processes[0].lanes.length === 2);
        assert(ast.processes[0].lanes[0].name === 'Customer');
        assert(ast.processes[0].lanes[0].elements.length === 2);
        assert(ast.processes[0].lanes[0].elements[0].name === 'place order');
      });
      
      // Test 3: Gateway Parsing
      test('Should parse gateways with branches', () => {
        const parser = new BpmnLiteParser();
        const dsl = `
@System
  validate payment
  ?Payment OK
    +ship order
    -cancel order
`;
        const ast = parser.parse(dsl);
        
        const elements = ast.processes[0].lanes[0].elements;
        const gateway = elements.find(e => e.type === 'gateway');
        assert(gateway !== undefined);
        assert(gateway.name === 'Payment OK');
        assert(gateway.branches.length === 2);
      });
      
      // Test 4: Message Flow Parsing
      test('Should parse send/receive message tasks', () => {
        const parser = new BpmnLiteParser();
        const dsl = `
@Customer
  send: Payment Info
@System
  receive: Payment Info
`;
        const ast = parser.parse(dsl);
        
        const customerLane = ast.processes[0].lanes[0];
        const systemLane = ast.processes[0].lanes[1];
        
        assert(customerLane.elements[0].type === 'send');
        assert(customerLane.elements[0].messageName === 'Payment Info');
        assert(systemLane.elements[0].type === 'receive');
        assert(systemLane.elements[0].messageName === 'Payment Info');
      });
      
      // Test 5: Explicit Connection Parsing
      test('Should parse explicit connections', () => {
        const parser = new BpmnLiteParser();
        const dsl = `
@Lane1
  task A -> task C
`;
        const ast = parser.parse(dsl);
        
        // Check that connections were created
        const hasConnection = ast.connections.some(conn => 
          conn.sourceRef.includes('task_a') && 
          conn.targetRef.includes('task_c')
        );
        assert(hasConnection);
      });
      
      // Test 6: Data Object Parsing
      test('Should parse data objects', () => {
        const parser = new BpmnLiteParser();
        const dsl = `
@Customer
  place order
#OrderData place order
`;
        const ast = parser.parse(dsl);
        
        assert(ast.dataObjects.length === 1);
        assert(ast.dataObjects[0].name === 'OrderData');
        assert(ast.dataObjects[0].taskRef === 'place order');
      });
      
      // Test 7: Comment Parsing
      test('Should parse comments', () => {
        const parser = new BpmnLiteParser();
        const dsl = `
@Lane1
  task one
  "This is a comment
  task two
`;
        const ast = parser.parse(dsl);
        
        const comment = ast.processes[0].lanes[0].elements.find(e => e.type === 'comment');
        assert(comment !== undefined);
        assert(comment.name === 'This is a comment');
      });
      
      // Test 8: Event Parsing
      test('Should parse start and end events', () => {
        const parser = new BpmnLiteParser();
        const dsl = `
@Lane1
  !Start
  do something
  !End
`;
        const ast = parser.parse(dsl);
        
        const elements = ast.processes[0].lanes[0].elements;
        const startEvent = elements.find(e => e.type === 'event' && e.eventType === 'start');
        const endEvent = elements.find(e => e.type === 'event' && e.eventType === 'end');
        
        assert(startEvent !== undefined);
        assert(endEvent !== undefined);
      });
      
      // Test 9: Custom Gateway Labels
      test('Should parse custom gateway labels', () => {
        const parser = new BpmnLiteParser();
        const dsl = `
@System
  ?Payment Method
    +|Credit Card| process card
    +|PayPal| process paypal
    -|Cancel| cancel order
`;
        const ast = parser.parse(dsl);
        
        const elements = ast.processes[0].lanes[0].elements;
        const creditBranch = elements.find(e => e.type === 'branch' && e.label === 'Credit Card');
        
        assert(creditBranch !== undefined);
        assert(creditBranch.name === 'process card');
      });
      
      // Test 10: Cross-Lane Message Flows
      test('Should parse explicit cross-lane message flows', () => {
        const parser = new BpmnLiteParser();
        const dsl = `
@Customer
  place order
@System
  process order
^OrderInfo @Customer.place order -> @System.process order
`;
        const ast = parser.parse(dsl);
        
        const messageFlow = ast.connections.find(conn => 
          conn.type === 'messageFlow' && 
          conn.name === 'OrderInfo'
        );
        
        assert(messageFlow !== undefined);
      });
      
      // Test 11: Sequential Task Connection
      test('Should automatically connect sequential tasks', () => {
        const parser = new BpmnLiteParser();
        const dsl = `
@Lane1
  task one
  task two
  task three
`;
        const ast = parser.parse(dsl);
        
        // Should have 2 connections for 3 tasks
        const sequenceFlows = ast.connections.filter(conn => conn.type === 'sequenceFlow');
        assert(sequenceFlows.length >= 2);
      });
      
      // Test 12: Empty DSL Handling
      test('Should handle empty DSL gracefully', () => {
        const parser = new BpmnLiteParser();
        const dsl = '';
        const ast = parser.parse(dsl);
        
        assert(ast.type === 'bpmnModel');
        assert(ast.processes.length >= 0);
      });
      
      // Test 13: Whitespace Insensitivity
      test('Should be whitespace insensitive', () => {
        const parser = new BpmnLiteParser();
        const dsl = `
    :Process Name
      @Lane1
        task one
          task two
@Lane2
task three
`;
        const ast = parser.parse(dsl);
        
        assert(ast.processes[0].name === 'Process Name');
        assert(ast.processes[0].lanes.length === 2);
      });
      
      // Test 14: Mermaid Generation
      test('Should generate valid Mermaid syntax', () => {
        const parser = new BpmnLiteParser();
        const dsl = `
:Test Process
@Lane1
  task one
  task two
`;
        parser.parse(dsl);
        const mermaid = parser.toMermaid();
        
        assert(mermaid.includes('flowchart TD'));
        assert(mermaid.includes('subgraph'));
        assert(mermaid.includes('task_one'));
      });
      
      // Display results
      displayResults();
    }
    
    function displayResults() {
      const resultsDiv = document.getElementById('test-results');
      const passedTests = results.filter(r => r.passed).length;
      
      let html = `<div class="test-summary">Test Results: ${passedTests}/${results.length} passed</div>`;
      
      results.forEach(result => {
        if (result.passed) {
          html += `<div class="test-result test-pass"> ${result.name}</div>`;
        } else {
          html += `<div class="test-result test-fail">
             ${result.name}
            <div class="test-error">${result.error}</div>
          </div>`;
        }
      });
      
      resultsDiv.innerHTML = html;
    }
    
    // Run tests on page load
    window.addEventListener('load', () => {
      console.log('Test page loaded. Click "Run Tests" to execute the test suite.');
    });
  </script>
</body>
</html>